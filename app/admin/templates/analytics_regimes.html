{% extends "layout.html" %}

{% block title %}Regime Analytics - KB Admin{% endblock %}

{% block content %}
<style>
    /* Analytics-specific styles */
    .page-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
    }

    .page-header h1 {
        font-size: 24px;
        font-weight: 600;
    }

    .last-updated {
        color: var(--text-muted);
        font-size: 12px;
    }

    /* Filters */
    .filter-row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
        margin-bottom: 24px;
        padding: 16px;
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 6px;
    }

    .filter-group {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }

    .filter-label {
        font-size: 11px;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    /* Grid layout */
    .analytics-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
        margin-bottom: 24px;
    }

    @media (max-width: 1200px) {
        .analytics-grid {
            grid-template-columns: 1fr;
        }
    }

    /* Chart container */
    .chart-container {
        min-height: 200px;
    }

    .tier-bars {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .tier-bar-row {
        display: flex;
        align-items: center;
        gap: 12px;
    }

    .tier-label {
        width: 100px;
        font-size: 13px;
        text-align: right;
    }

    .tier-bar-container {
        flex: 1;
        height: 28px;
        background: var(--bg);
        border-radius: 4px;
        overflow: hidden;
        position: relative;
    }

    .tier-bar {
        height: 100%;
        border-radius: 4px;
        transition: width 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        padding-right: 8px;
    }

    .tier-bar-value {
        font-size: 12px;
        font-weight: 500;
        color: white;
        text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .tier-exact { background: var(--success); }
    .tier-partial_trend { background: #3b82f6; }
    .tier-partial_vol { background: #8b5cf6; }
    .tier-distance { background: var(--warning); }
    .tier-global_best { background: var(--danger); }

    /* Toggle button group */
    .toggle-group {
        display: flex;
        border: 1px solid var(--border);
        border-radius: 6px;
        overflow: hidden;
    }

    .toggle-btn {
        background: var(--bg);
        color: var(--text-muted);
        border: none;
        padding: 4px 12px;
        font-size: 12px;
        cursor: pointer;
        border-right: 1px solid var(--border);
    }

    .toggle-btn:last-child {
        border-right: none;
    }

    .toggle-btn:hover {
        color: var(--text);
    }

    .toggle-btn.active {
        background: var(--link);
        color: white;
    }

    /* Time-series vertical stacked bars with confidence overlay */
    .timeseries-chart {
        position: relative;
        height: 180px;
        margin-bottom: 8px;
    }

    .timeseries-bars-container {
        display: flex;
        align-items: flex-end;
        justify-content: space-between;
        height: 150px;
        padding: 0 4px;
        border-bottom: 1px solid var(--border);
        position: relative;
    }

    .timeseries-bar-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
        max-width: 40px;
        position: relative;
    }

    .timeseries-bar {
        width: 24px;
        display: flex;
        flex-direction: column-reverse;
        border-radius: 3px 3px 0 0;
        overflow: hidden;
        cursor: pointer;
        position: relative;
    }

    .timeseries-segment {
        width: 100%;
        min-height: 2px;
        transition: opacity 0.2s;
    }

    .timeseries-bar:hover .timeseries-segment {
        opacity: 0.8;
    }

    .timeseries-labels {
        display: flex;
        justify-content: space-between;
        padding: 4px 4px 0;
    }

    .timeseries-label {
        flex: 1;
        max-width: 40px;
        font-size: 10px;
        color: var(--text-muted);
        text-align: center;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* Confidence line overlay */
    .confidence-line-container {
        position: absolute;
        top: 0;
        left: 4px;
        right: 4px;
        height: 150px;
        pointer-events: none;
    }

    .confidence-line {
        fill: none;
        stroke: var(--link);
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
    }

    .confidence-dot {
        fill: var(--link);
        stroke: var(--bg-secondary);
        stroke-width: 2;
    }

    /* Y-axis for confidence */
    .confidence-axis {
        position: absolute;
        right: -30px;
        top: 0;
        height: 150px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        font-size: 10px;
        color: var(--text-muted);
    }

    .timeseries-legend {
        display: flex;
        gap: 16px;
        margin-top: 8px;
        flex-wrap: wrap;
        align-items: center;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 4px;
        font-size: 11px;
        color: var(--text-muted);
    }

    .legend-dot {
        width: 10px;
        height: 10px;
        border-radius: 2px;
    }

    .legend-line {
        width: 16px;
        height: 2px;
        background: var(--link);
        border-radius: 1px;
    }

    /* Tooltip */
    .chart-tooltip {
        position: fixed;
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 6px;
        padding: 10px 12px;
        font-size: 12px;
        z-index: 1000;
        pointer-events: none;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        max-width: 200px;
    }

    .chart-tooltip-title {
        font-weight: 600;
        margin-bottom: 6px;
        color: var(--text);
    }

    .chart-tooltip-row {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        margin: 2px 0;
    }

    .chart-tooltip-label {
        color: var(--text-muted);
    }

    .chart-tooltip-value {
        font-weight: 500;
    }

    .chart-tooltip-divider {
        border-top: 1px solid var(--border);
        margin: 6px 0;
    }

    /* Insight cards */
    .insight-cards {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
    }

    @media (max-width: 900px) {
        .insight-cards {
            grid-template-columns: 1fr;
        }
    }

    .insight-card {
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 6px;
        padding: 16px;
    }

    .insight-title {
        font-size: 14px;
        font-weight: 600;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .insight-icon {
        font-size: 16px;
    }

    .insight-list {
        list-style: none;
    }

    .insight-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid var(--border);
        font-size: 13px;
    }

    .insight-item:last-child {
        border-bottom: none;
    }

    .insight-regime {
        font-family: 'SF Mono', Consolas, monospace;
        color: var(--link);
        cursor: pointer;
    }

    .insight-value {
        font-weight: 500;
    }

    .insight-value.negative {
        color: var(--danger);
    }

    .insight-value.positive {
        color: var(--success);
    }

    /* Backlog panel */
    .backlog-panel {
        display: none;
        margin-top: 24px;
    }

    .backlog-panel.visible {
        display: block;
    }

    .backlog-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
    }

    .backlog-header h2 {
        font-size: 18px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .backlog-summary {
        display: flex;
        gap: 24px;
        margin-bottom: 16px;
    }

    .backlog-stat {
        text-align: center;
    }

    .backlog-stat-value {
        font-size: 24px;
        font-weight: 600;
    }

    .backlog-stat-label {
        font-size: 12px;
        color: var(--text-muted);
    }

    .backlog-item {
        background: var(--bg);
        border: 1px solid var(--border);
        border-radius: 6px;
        padding: 12px;
        margin-bottom: 12px;
    }

    .backlog-item-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
    }

    .backlog-regime {
        font-family: 'SF Mono', Consolas, monospace;
        font-size: 13px;
        color: var(--link);
    }

    .priority-badge {
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 500;
        text-transform: uppercase;
    }

    .priority-high {
        background: rgba(248, 81, 73, 0.2);
        color: var(--danger);
    }

    .priority-medium {
        background: rgba(210, 153, 34, 0.2);
        color: var(--warning);
    }

    .priority-low {
        background: rgba(139, 148, 158, 0.2);
        color: var(--text-muted);
    }

    .backlog-details {
        display: flex;
        gap: 24px;
        font-size: 13px;
        color: var(--text-muted);
    }

    .backlog-detail-label {
        font-weight: 500;
        color: var(--text);
    }

    .action-btn {
        margin-top: 12px;
    }

    .action-btn button {
        width: 100%;
    }

    /* Coverage table */
    .coverage-table-container {
        overflow-x: auto;
    }

    th.sortable {
        cursor: pointer;
        user-select: none;
    }

    th.sortable:hover {
        color: var(--text);
    }

    th.sortable::after {
        content: ' ';
        display: inline-block;
        width: 16px;
    }

    th.sortable.asc::after {
        content: ' \2191';
    }

    th.sortable.desc::after {
        content: ' \2193';
    }

    .coverage-gap {
        color: var(--warning);
    }

    .coverage-gap.zero {
        color: var(--text-muted);
    }

    /* Summary stats */
    .summary-stats {
        display: flex;
        gap: 32px;
        margin-bottom: 16px;
    }

    .summary-stat {
        text-align: center;
    }

    .summary-value {
        font-size: 28px;
        font-weight: 600;
    }

    .summary-label {
        font-size: 12px;
        color: var(--text-muted);
    }

    /* Loading / Error states */
    .loading {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 150px;
        color: var(--text-muted);
    }

    .loading-spinner {
        width: 24px;
        height: 24px;
        border: 2px solid var(--border);
        border-top-color: var(--link);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 12px;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }

    .error-state {
        text-align: center;
        padding: 24px;
        color: var(--danger);
    }
</style>

<div class="page-header">
    <h1>Regime Analytics</h1>
    <div>
        <span class="last-updated" id="lastUpdated">Loading...</span>
        <button onclick="refreshData()" class="btn-secondary" style="margin-left: 12px;">Refresh</button>
    </div>
</div>

<!-- Filters -->
<div class="filter-row">
    <div class="filter-group">
        <span class="filter-label">Workspace</span>
        <select id="workspaceSelect" onchange="onFilterChange()">
            <option value="">Loading...</option>
        </select>
    </div>
    <div class="filter-group">
        <span class="filter-label">Strategy</span>
        <select id="strategySelect" onchange="onFilterChange()">
            <option value="">All Strategies</option>
        </select>
    </div>
    <div class="filter-group">
        <span class="filter-label">Period</span>
        <select id="periodSelect" onchange="onFilterChange()">
            <option value="7">Last 7 days</option>
            <option value="30" selected>Last 30 days</option>
            <option value="90">Last 90 days</option>
            <option value="365">All time</option>
        </select>
    </div>
    <div class="filter-group">
        <span class="filter-label">Min Samples</span>
        <input type="number" id="minSamplesInput" value="5" min="1" max="100" style="width: 80px;" onchange="onFilterChange()">
    </div>
</div>

<!-- Summary Stats -->
<div class="card">
    <div class="summary-stats" id="summaryStats">
        <div class="summary-stat">
            <div class="summary-value" id="totalRecommends">-</div>
            <div class="summary-label">Total Recommends</div>
        </div>
        <div class="summary-stat">
            <div class="summary-value" id="totalRegimes">-</div>
            <div class="summary-label">Unique Regimes</div>
        </div>
        <div class="summary-stat">
            <div class="summary-value" id="coveragePct">-</div>
            <div class="summary-label">Coverage %</div>
        </div>
        <div class="summary-stat">
            <div class="summary-value" id="overallUplift">-</div>
            <div class="summary-label">Avg Uplift</div>
        </div>
    </div>
</div>

<!-- Charts Grid -->
<div class="analytics-grid">
    <!-- Tier Usage -->
    <div class="card">
        <div class="card-header">
            <span class="card-title">Tier Usage Distribution</span>
            <div style="display: flex; gap: 12px; align-items: center;">
                <div class="toggle-group">
                    <button class="toggle-btn active" id="btnTotals" onclick="toggleTimeMode('totals')">Totals</button>
                    <button class="toggle-btn" id="btnOverTime" onclick="toggleTimeMode('timeseries')">Over time</button>
                </div>
                <div id="viewModeControls">
                    <button class="btn-secondary" style="padding: 4px 8px; font-size: 12px;" onclick="toggleTierView('count')" id="btnCount">Count</button>
                    <button class="btn-secondary" style="padding: 4px 8px; font-size: 12px;" onclick="toggleTierView('pct')" id="btnPct">%</button>
                </div>
            </div>
        </div>
        <div class="chart-container" id="tierChartContainer">
            <div class="loading">
                <div class="loading-spinner"></div>
                Loading tier data...
            </div>
        </div>
    </div>

    <!-- Confidence by Tier -->
    <div class="card">
        <div class="card-header">
            <span class="card-title">Avg Confidence by Tier</span>
        </div>
        <div class="chart-container" id="confidenceChartContainer">
            <div class="loading">
                <div class="loading-spinner"></div>
                Loading...
            </div>
        </div>
    </div>
</div>

<!-- Insight Cards -->
<div class="insight-cards">
    <div class="insight-card">
        <div class="insight-title">
            <span class="insight-icon">&#9888;</span>
            Worst Coverage (Top 5)
        </div>
        <ul class="insight-list" id="worstCoverageList">
            <li class="loading">
                <div class="loading-spinner"></div>
                Loading...
            </li>
        </ul>
        <div class="action-btn">
            <button onclick="generateTuningPlan()" id="btnGeneratePlan" class="btn-secondary">
                Generate tuning plan
            </button>
        </div>
    </div>

    <div class="insight-card">
        <div class="insight-title">
            <span class="insight-icon">&#10003;</span>
            Best Uplift Regimes (Top 5)
        </div>
        <ul class="insight-list" id="bestUpliftList">
            <li class="loading">
                <div class="loading-spinner"></div>
                Loading...
            </li>
        </ul>
    </div>
</div>

<!-- Backlog Panel (hidden by default) -->
<div class="backlog-panel card" id="backlogPanel">
    <div class="backlog-header">
        <h2>
            <span>&#128203;</span>
            Tuning Backlog
        </h2>
        <button class="btn-secondary" style="padding: 4px 12px; font-size: 12px;" onclick="hideBacklogPanel()">
            Close
        </button>
    </div>
    <div class="backlog-summary" id="backlogSummary">
        <div class="backlog-stat">
            <div class="backlog-stat-value" id="backlogTotalGaps">-</div>
            <div class="backlog-stat-label">Regimes with gaps</div>
        </div>
        <div class="backlog-stat">
            <div class="backlog-stat-value" id="backlogTotalMissing">-</div>
            <div class="backlog-stat-label">Total tunes needed</div>
        </div>
    </div>
    <div id="backlogItems">
        <!-- Backlog items will be rendered here -->
    </div>
</div>

<!-- Coverage Table -->
<div class="card" style="margin-top: 24px;">
    <div class="card-header">
        <span class="card-title">Regime Coverage Details</span>
        <span class="badge badge-type" id="regimeCount">0 regimes</span>
    </div>
    <div class="coverage-table-container">
        <table id="coverageTable">
            <thead>
                <tr>
                    <th class="sortable" data-sort="regime_key">Regime Key</th>
                    <th class="sortable" data-sort="trend_tag">Trend</th>
                    <th class="sortable" data-sort="vol_tag">Vol</th>
                    <th class="sortable" data-sort="n_tunes">Tunes</th>
                    <th class="sortable" data-sort="n_runs">Runs</th>
                    <th class="sortable" data-sort="avg_best_oos">Avg Score</th>
                    <th class="sortable" data-sort="p50_best_oos">P50</th>
                    <th class="sortable" data-sort="p90_best_oos">P90</th>
                    <th>Status</th>
                    <th class="sortable desc" data-sort="coverage_gap">Gap</th>
                </tr>
            </thead>
            <tbody id="coverageTableBody">
                <tr>
                    <td colspan="10" class="loading">
                        <div class="loading-spinner"></div>
                        Loading coverage data...
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<script>
    // State
    let tierData = null;
    let tierTimeSeriesData = null;
    let coverageData = null;
    let upliftData = null;
    let currentTierView = 'pct';
    let currentTimeMode = 'totals';  // 'totals' or 'timeseries'
    let currentSort = { column: 'coverage_gap', direction: 'desc' };

    // Config from server
    const workspaceId = '{{ workspace_id }}';
    const adminToken = '{{ admin_token }}';

    // API helpers
    async function fetchWithAuth(url) {
        const response = await fetch(url, {
            headers: {
                'X-Admin-Token': adminToken
            }
        });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json();
    }

    function getFilterParams() {
        const workspace = document.getElementById('workspaceSelect').value || workspaceId;
        const strategy = document.getElementById('strategySelect').value;
        const period = document.getElementById('periodSelect').value;
        const minSamples = document.getElementById('minSamplesInput').value || 5;

        let params = `workspace_id=${workspace}&period_days=${period}&min_samples=${minSamples}`;
        if (strategy) {
            params += `&strategy_entity_id=${strategy}`;
        }
        return params;
    }

    // Data loading
    async function loadAllData() {
        const params = getFilterParams();

        try {
            // Fetch all endpoints in parallel (always get totals + optionally time-series)
            const fetches = [
                fetchWithAuth(`/admin/analytics/tier-usage?${params}`),
                fetchWithAuth(`/admin/analytics/regime-coverage?${params}`),
                fetchWithAuth(`/admin/analytics/uplift?${params}`)
            ];

            // Also fetch time-series if in that mode
            if (currentTimeMode === 'timeseries') {
                fetches.push(fetchWithAuth(`/admin/analytics/tier-usage?${params}&bucket=day`));
            }

            const results = await Promise.all(fetches);

            tierData = results[0];
            coverageData = results[1];
            upliftData = results[2];
            tierTimeSeriesData = results[3] || null;

            renderAll();
            updateLastUpdated();
        } catch (error) {
            console.error('Failed to load data:', error);
            showError(error.message);
        }
    }

    // Toggle between totals and time-series view
    async function toggleTimeMode(mode) {
        if (currentTimeMode === mode) return;
        currentTimeMode = mode;

        // Update toggle button states
        document.getElementById('btnTotals').classList.toggle('active', mode === 'totals');
        document.getElementById('btnOverTime').classList.toggle('active', mode === 'timeseries');

        // Show/hide count/% controls (only relevant for totals)
        document.getElementById('viewModeControls').style.display = mode === 'totals' ? 'block' : 'none';

        // If switching to timeseries and no data yet, fetch it
        if (mode === 'timeseries' && !tierTimeSeriesData) {
            const params = getFilterParams();
            try {
                tierTimeSeriesData = await fetchWithAuth(`/admin/analytics/tier-usage?${params}&bucket=day`);
            } catch (error) {
                console.error('Failed to load time-series data:', error);
            }
        }

        renderTierChart();
    }

    function renderAll() {
        renderSummaryStats();
        renderTierChart();
        renderConfidenceChart();
        renderInsightCards();
        renderCoverageTable();
    }

    // Summary stats
    function renderSummaryStats() {
        document.getElementById('totalRecommends').textContent =
            tierData?.total_recommendations?.toLocaleString() || '0';
        document.getElementById('totalRegimes').textContent =
            coverageData?.total_regimes?.toLocaleString() || '0';
        document.getElementById('coveragePct').textContent =
            (coverageData?.coverage_pct?.toFixed(1) || '0') + '%';

        const uplift = upliftData?.overall_uplift || 0;
        const upliftEl = document.getElementById('overallUplift');
        upliftEl.textContent = (uplift >= 0 ? '+' : '') + uplift.toFixed(4);
        upliftEl.style.color = uplift >= 0 ? 'var(--success)' : 'var(--danger)';
    }

    // Tier chart
    function renderTierChart() {
        const container = document.getElementById('tierChartContainer');

        // Time-series mode
        if (currentTimeMode === 'timeseries') {
            renderTierTimeSeriesChart(container);
            return;
        }

        // Totals mode
        if (!tierData?.items?.length) {
            container.innerHTML = '<div class="empty-state">No recommendation events in this period</div>';
            return;
        }

        const tierOrder = ['exact', 'partial_trend', 'partial_vol', 'distance', 'global_best'];
        const tierLabels = {
            'exact': 'Exact',
            'partial_trend': 'Partial (Trend)',
            'partial_vol': 'Partial (Vol)',
            'distance': 'Distance',
            'global_best': 'Global Best'
        };

        // Sort items by tier order
        const sortedItems = tierOrder.map(tier =>
            tierData.items.find(i => i.tier === tier) || { tier, count: 0, pct: 0 }
        );

        const maxValue = currentTierView === 'count'
            ? Math.max(...sortedItems.map(i => i.count))
            : 100;

        let html = '<div class="tier-bars">';
        for (const item of sortedItems) {
            const value = currentTierView === 'count' ? item.count : item.pct;
            const width = maxValue > 0 ? (value / maxValue * 100) : 0;
            const display = currentTierView === 'count'
                ? item.count.toLocaleString()
                : item.pct.toFixed(1) + '%';

            html += `
                <div class="tier-bar-row">
                    <div class="tier-label">${tierLabels[item.tier]}</div>
                    <div class="tier-bar-container">
                        <div class="tier-bar tier-${item.tier}" style="width: ${width}%">
                            <span class="tier-bar-value">${display}</span>
                        </div>
                    </div>
                </div>
            `;
        }
        html += '</div>';

        container.innerHTML = html;

        // Update button states
        document.getElementById('btnCount').classList.toggle('active', currentTierView === 'count');
        document.getElementById('btnPct').classList.toggle('active', currentTierView === 'pct');
    }

    // Render time-series vertical stacked bar chart with confidence line overlay
    function renderTierTimeSeriesChart(container) {
        if (!tierTimeSeriesData?.buckets?.length) {
            container.innerHTML = '<div class="empty-state">No time-series data available</div>';
            return;
        }

        const tierOrder = ['exact', 'partial_trend', 'partial_vol', 'distance', 'global_best'];
        const tierLabels = {
            'exact': 'Exact',
            'partial_trend': 'Partial (T)',
            'partial_vol': 'Partial (V)',
            'distance': 'Distance',
            'global_best': 'Global'
        };
        const tierColors = {
            'exact': '#3fb950',
            'partial_trend': '#3b82f6',
            'partial_vol': '#8b5cf6',
            'distance': '#d29922',
            'global_best': '#f85149'
        };

        // Group series data by bucket
        const bucketData = {};
        for (const bucket of tierTimeSeriesData.buckets) {
            bucketData[bucket] = { total: 0 };
            for (const tier of tierOrder) {
                bucketData[bucket][tier] = 0;
            }
        }

        for (const item of tierTimeSeriesData.series) {
            if (bucketData[item.bucket_start]) {
                bucketData[item.bucket_start][item.tier] = item.count;
                bucketData[item.bucket_start].total += item.count;
            }
        }

        // Build confidence lookup
        const confidenceByBucket = {};
        for (const conf of (tierTimeSeriesData.confidence_series || [])) {
            confidenceByBucket[conf.bucket_start] = conf.avg_confidence;
        }

        // Find max total for scaling bars
        const maxTotal = Math.max(...Object.values(bucketData).map(d => d.total), 1);
        const chartHeight = 150;
        const buckets = tierTimeSeriesData.buckets;
        const barCount = buckets.length;

        // Build bars HTML
        let barsHtml = '';
        for (let i = 0; i < buckets.length; i++) {
            const bucket = buckets[i];
            const data = bucketData[bucket];
            const barHeight = (data.total / maxTotal) * chartHeight;
            const confidence = confidenceByBucket[bucket] || 0;

            // Build tooltip data attribute
            const tooltipData = JSON.stringify({
                bucket: bucket,
                total: data.total,
                confidence: confidence,
                tiers: tierOrder.map(t => ({ tier: t, count: data[t] }))
            });

            barsHtml += `<div class="timeseries-bar-wrapper">
                <div class="timeseries-bar"
                     style="height: ${barHeight}px"
                     data-tooltip='${tooltipData}'
                     onmouseenter="showChartTooltip(event, this)"
                     onmouseleave="hideChartTooltip()">`;

            // Stacked segments (bottom to top)
            for (const tier of tierOrder) {
                const count = data[tier];
                if (count > 0) {
                    const segmentHeight = (count / data.total) * barHeight;
                    barsHtml += `<div class="timeseries-segment tier-${tier}" style="height: ${segmentHeight}px"></div>`;
                }
            }

            barsHtml += `</div></div>`;
        }

        // Build confidence line SVG path
        let linePath = '';
        let dots = '';
        if (buckets.length > 0) {
            const points = [];
            for (let i = 0; i < buckets.length; i++) {
                const bucket = buckets[i];
                const confidence = confidenceByBucket[bucket] || 0;
                // Calculate x position (center of each bar area)
                const x = (i / (buckets.length - 1 || 1)) * 100;
                // y: 0 = top (conf=1.0), chartHeight = bottom (conf=0)
                const y = (1 - confidence) * chartHeight;
                points.push({ x, y, confidence });
            }

            if (points.length === 1) {
                // Single point - just a dot
                dots = `<circle class="confidence-dot" cx="${points[0].x}%" cy="${points[0].y}" r="4"/>`;
            } else {
                // Build line path
                linePath = `M ${points[0].x}% ${points[0].y}`;
                for (let i = 1; i < points.length; i++) {
                    linePath += ` L ${points[i].x}% ${points[i].y}`;
                }
                // Add dots at each point
                dots = points.map(p =>
                    `<circle class="confidence-dot" cx="${p.x}%" cy="${p.y}" r="3"/>`
                ).join('');
            }
        }

        // Build labels (show subset if too many)
        let labelsHtml = '';
        const maxLabels = 10;
        const step = buckets.length <= maxLabels ? 1 : Math.ceil(buckets.length / maxLabels);
        for (let i = 0; i < buckets.length; i++) {
            const bucket = buckets[i];
            const date = new Date(bucket);
            const label = (i % step === 0)
                ? date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
                : '';
            labelsHtml += `<div class="timeseries-label">${label}</div>`;
        }

        // Legend
        let legendHtml = '';
        for (const tier of tierOrder) {
            legendHtml += `
                <div class="legend-item">
                    <div class="legend-dot" style="background: ${tierColors[tier]}"></div>
                    ${tierLabels[tier]}
                </div>`;
        }
        legendHtml += `
            <div class="legend-item">
                <div class="legend-line"></div>
                Avg Confidence
            </div>`;

        // Combine all parts
        container.innerHTML = `
            <div class="timeseries-chart">
                <div class="timeseries-bars-container">
                    ${barsHtml}
                    <svg class="confidence-line-container" preserveAspectRatio="none">
                        <path class="confidence-line" d="${linePath}"/>
                        ${dots}
                    </svg>
                    <div class="confidence-axis">
                        <span>1.0</span>
                        <span>0.5</span>
                        <span>0.0</span>
                    </div>
                </div>
                <div class="timeseries-labels">${labelsHtml}</div>
            </div>
            <div class="timeseries-legend">${legendHtml}</div>
        `;
    }

    // Chart tooltip handlers
    let tooltipEl = null;

    function showChartTooltip(event, element) {
        const data = JSON.parse(element.dataset.tooltip);
        const date = new Date(data.bucket);
        const dateStr = date.toLocaleDateString('en-US', {
            weekday: 'short', month: 'short', day: 'numeric'
        });

        const tierLabels = {
            'exact': 'Exact',
            'partial_trend': 'Partial (T)',
            'partial_vol': 'Partial (V)',
            'distance': 'Distance',
            'global_best': 'Global'
        };

        let tierRows = data.tiers
            .filter(t => t.count > 0)
            .map(t => `
                <div class="chart-tooltip-row">
                    <span class="chart-tooltip-label">${tierLabels[t.tier]}</span>
                    <span class="chart-tooltip-value">${t.count}</span>
                </div>
            `).join('');

        if (!tooltipEl) {
            tooltipEl = document.createElement('div');
            tooltipEl.className = 'chart-tooltip';
            document.body.appendChild(tooltipEl);
        }

        tooltipEl.innerHTML = `
            <div class="chart-tooltip-title">${dateStr}</div>
            <div class="chart-tooltip-row">
                <span class="chart-tooltip-label">Total</span>
                <span class="chart-tooltip-value">${data.total}</span>
            </div>
            <div class="chart-tooltip-row">
                <span class="chart-tooltip-label">Confidence</span>
                <span class="chart-tooltip-value" style="color: var(--link)">${data.confidence.toFixed(2)}</span>
            </div>
            <div class="chart-tooltip-divider"></div>
            ${tierRows}
        `;

        tooltipEl.style.display = 'block';

        // Position tooltip near cursor
        const rect = element.getBoundingClientRect();
        tooltipEl.style.left = (rect.left + rect.width / 2) + 'px';
        tooltipEl.style.top = (rect.top - 10) + 'px';
        tooltipEl.style.transform = 'translate(-50%, -100%)';
    }

    function hideChartTooltip() {
        if (tooltipEl) {
            tooltipEl.style.display = 'none';
        }
    }

    function toggleTierView(view) {
        currentTierView = view;
        renderTierChart();
    }

    // Confidence chart
    function renderConfidenceChart() {
        const container = document.getElementById('confidenceChartContainer');

        if (!tierData?.items?.length) {
            container.innerHTML = '<div class="empty-state">No data</div>';
            return;
        }

        const tierOrder = ['exact', 'partial_trend', 'partial_vol', 'distance', 'global_best'];
        const tierLabels = {
            'exact': 'Exact',
            'partial_trend': 'Partial (T)',
            'partial_vol': 'Partial (V)',
            'distance': 'Distance',
            'global_best': 'Global'
        };

        let html = '<div class="tier-bars">';
        for (const tier of tierOrder) {
            const item = tierData.items.find(i => i.tier === tier);
            const confidence = item?.avg_confidence || 0;
            const width = confidence * 100;

            html += `
                <div class="tier-bar-row">
                    <div class="tier-label">${tierLabels[tier]}</div>
                    <div class="tier-bar-container">
                        <div class="tier-bar tier-${tier}" style="width: ${width}%">
                            <span class="tier-bar-value">${confidence.toFixed(2)}</span>
                        </div>
                    </div>
                </div>
            `;
        }
        html += '</div>';

        container.innerHTML = html;
    }

    // Insight cards
    function renderInsightCards() {
        // Worst coverage
        const worstList = document.getElementById('worstCoverageList');
        if (!coverageData?.items?.length) {
            worstList.innerHTML = '<li class="empty-state">No regime data</li>';
        } else {
            const minSamples = parseInt(document.getElementById('minSamplesInput').value) || 5;
            const withGap = coverageData.items
                .map(item => ({
                    ...item,
                    gap: Math.max(0, minSamples - item.n_tunes)
                }))
                .filter(item => item.gap > 0)
                .sort((a, b) => b.gap - a.gap)
                .slice(0, 5);

            if (withGap.length === 0) {
                worstList.innerHTML = '<li class="insight-item"><span style="color: var(--success);">All regimes meet min_samples!</span></li>';
            } else {
                worstList.innerHTML = withGap.map(item => `
                    <li class="insight-item">
                        <span class="insight-regime" onclick="filterByRegime('${item.regime_key}')">${truncate(item.regime_key, 30)}</span>
                        <span class="insight-value negative">-${item.gap} needed</span>
                    </li>
                `).join('');
            }
        }

        // Best uplift
        const bestList = document.getElementById('bestUpliftList');
        if (!upliftData?.by_regime?.length) {
            bestList.innerHTML = '<li class="empty-state">No uplift data (need recommend events)</li>';
        } else {
            const top5 = upliftData.by_regime
                .filter(item => item.n_recommendations >= 3)  // Minimum sample size
                .sort((a, b) => b.uplift - a.uplift)
                .slice(0, 5);

            if (top5.length === 0) {
                bestList.innerHTML = '<li class="insight-item"><span>Need more recommendations per regime</span></li>';
            } else {
                bestList.innerHTML = top5.map(item => `
                    <li class="insight-item">
                        <span class="insight-regime" onclick="filterByRegime('${item.group_key}')">${truncate(item.group_key, 30)}</span>
                        <span class="insight-value ${item.uplift >= 0 ? 'positive' : 'negative'}">
                            ${item.uplift >= 0 ? '+' : ''}${item.uplift.toFixed(4)} (n=${item.n_recommendations})
                        </span>
                    </li>
                `).join('');
            }
        }
    }

    // Coverage table
    function renderCoverageTable() {
        const tbody = document.getElementById('coverageTableBody');
        const countBadge = document.getElementById('regimeCount');

        if (!coverageData?.items?.length) {
            tbody.innerHTML = '<tr><td colspan="10" class="empty-state">No tunes/runs with OOS scores yet</td></tr>';
            countBadge.textContent = '0 regimes';
            return;
        }

        const minSamples = parseInt(document.getElementById('minSamplesInput').value) || 5;

        // Add coverage gap and sort
        let items = coverageData.items.map(item => ({
            ...item,
            coverage_gap: Math.max(0, minSamples - item.n_tunes)
        }));

        // Sort
        items.sort((a, b) => {
            let aVal = a[currentSort.column];
            let bVal = b[currentSort.column];

            // Handle nulls
            if (aVal === null) aVal = -Infinity;
            if (bVal === null) bVal = -Infinity;

            // String comparison
            if (typeof aVal === 'string') {
                return currentSort.direction === 'asc'
                    ? aVal.localeCompare(bVal)
                    : bVal.localeCompare(aVal);
            }

            // Numeric
            return currentSort.direction === 'asc' ? aVal - bVal : bVal - aVal;
        });

        tbody.innerHTML = items.map(item => `
            <tr>
                <td>
                    <code style="font-size: 12px; color: var(--link); cursor: pointer;"
                          onclick="filterByRegime('${item.regime_key}')">
                        ${truncate(item.regime_key, 40)}
                    </code>
                </td>
                <td>${item.trend_tag || '-'}</td>
                <td>${item.vol_tag || '-'}</td>
                <td>${item.n_tunes}</td>
                <td>${item.n_runs}</td>
                <td>${item.avg_best_oos?.toFixed(3) || '-'}</td>
                <td>${item.p50_best_oos?.toFixed(3) || '-'}</td>
                <td>${item.p90_best_oos?.toFixed(3) || '-'}</td>
                <td>
                    ${item.min_samples_met
                        ? '<span class="badge badge-verified">OK</span>'
                        : '<span class="badge badge-weak">Low</span>'}
                </td>
                <td class="coverage-gap ${item.coverage_gap === 0 ? 'zero' : ''}">
                    ${item.coverage_gap > 0 ? '-' + item.coverage_gap : '-'}
                </td>
            </tr>
        `).join('');

        countBadge.textContent = `${items.length} regimes`;

        // Update sort indicators
        document.querySelectorAll('th.sortable').forEach(th => {
            th.classList.remove('asc', 'desc');
            if (th.dataset.sort === currentSort.column) {
                th.classList.add(currentSort.direction);
            }
        });
    }

    // Sorting
    document.querySelectorAll('th.sortable').forEach(th => {
        th.addEventListener('click', () => {
            const column = th.dataset.sort;
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.column = column;
                currentSort.direction = 'desc';
            }
            renderCoverageTable();
        });
    });

    // Helpers
    function truncate(str, maxLen) {
        if (!str) return '-';
        return str.length > maxLen ? str.substring(0, maxLen) + '...' : str;
    }

    function filterByRegime(regimeKey) {
        // Future: Add regime filter to filters row
        console.log('Filter by regime:', regimeKey);
        alert('Regime filter: ' + regimeKey + '\n\nFilter functionality coming soon.');
    }

    function updateLastUpdated() {
        const now = new Date();
        document.getElementById('lastUpdated').textContent =
            'Last updated: ' + now.toLocaleTimeString();
    }

    function showError(message) {
        document.getElementById('tierChartContainer').innerHTML =
            `<div class="error-state">Error: ${message}</div>`;
        document.getElementById('coverageTableBody').innerHTML =
            `<tr><td colspan="10" class="error-state">Error: ${message}</td></tr>`;
    }

    function onFilterChange() {
        // Clear time-series cache on filter change
        tierTimeSeriesData = null;
        loadAllData();
    }

    function refreshData() {
        loadAllData();
    }

    // Backlog generation
    async function generateTuningPlan() {
        const btn = document.getElementById('btnGeneratePlan');
        const originalText = btn.textContent;
        btn.textContent = 'Generating...';
        btn.disabled = true;

        const workspace = document.getElementById('workspaceSelect').value || workspaceId;
        const strategy = document.getElementById('strategySelect').value;
        const minSamples = parseInt(document.getElementById('minSamplesInput').value) || 5;

        const requestBody = {
            workspace_id: workspace,
            min_samples: minSamples,
            max_items: 10
        };
        if (strategy) {
            requestBody.strategy_entity_id = strategy;
        }

        try {
            const response = await fetch('/admin/analytics/regime-backlog', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Admin-Token': adminToken
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            renderBacklog(data);
            showBacklogPanel();
        } catch (error) {
            console.error('Failed to generate tuning plan:', error);
            alert('Failed to generate tuning plan: ' + error.message);
        } finally {
            btn.textContent = originalText;
            btn.disabled = false;
        }
    }

    function renderBacklog(data) {
        document.getElementById('backlogTotalGaps').textContent = data.total_gaps;
        document.getElementById('backlogTotalMissing').textContent = data.total_missing;

        const container = document.getElementById('backlogItems');

        if (!data.regimes?.length) {
            container.innerHTML = '<div class="empty-state">No coverage gaps found. All regimes meet the minimum samples threshold!</div>';
            return;
        }

        container.innerHTML = data.regimes.map(item => `
            <div class="backlog-item">
                <div class="backlog-item-header">
                    <span class="backlog-regime">${truncate(item.regime_key, 50)}</span>
                    <span class="priority-badge priority-${item.suggested_actions.priority}">${item.suggested_actions.priority}</span>
                </div>
                <div class="backlog-details">
                    <span>
                        <span class="backlog-detail-label">Current:</span> ${item.current_tunes}
                    </span>
                    <span>
                        <span class="backlog-detail-label">Needed:</span> +${item.missing_samples}
                    </span>
                    <span>
                        <span class="backlog-detail-label">Timeframes:</span> ${item.suggested_actions.timeframes.join(', ')}
                    </span>
                    <span>
                        <span class="backlog-detail-label">Symbols:</span> ${item.suggested_actions.symbols.join(', ')}
                    </span>
                </div>
            </div>
        `).join('');
    }

    function showBacklogPanel() {
        document.getElementById('backlogPanel').classList.add('visible');
        document.getElementById('backlogPanel').scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    function hideBacklogPanel() {
        document.getElementById('backlogPanel').classList.remove('visible');
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
        // Set workspace in dropdown
        const wsSelect = document.getElementById('workspaceSelect');
        wsSelect.innerHTML = `<option value="${workspaceId}" selected>${workspaceId}</option>`;

        // Load data
        loadAllData();
    });
</script>
{% endblock %}
