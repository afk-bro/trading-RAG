<!DOCTYPE html>
<html>
<head>
    <title>API Test</title>
    <style>
        body { font-family: monospace; padding: 20px; }
        pre { background: #f0f0f0; padding: 10px; overflow: auto; max-height: 600px; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        .result { margin-top: 20px; }
    </style>
</head>
<body>
    <h1>RAG API Test</h1>
    <button onclick="testIngest()">Test Ingest</button>
    <button onclick="testQuery()">Test Query</button>
    <button onclick="checkHealth()">Check Health</button>
    <button onclick="checkChunkVectors()">Check Chunk Vectors</button>
    <button onclick="checkDocuments()">Check Documents</button>
    <button onclick="checkChunks()">Check Chunks</button>
    <button onclick="testDuplicateIngest()">Test Duplicate</button>
    <button onclick="testYouTubeIngest()">Test YouTube</button>
    <button onclick="testReembed()">Test Reembed</button>
    <button onclick="testWorkspaceIsolation()">Test Workspace Isolation</button>
    <button onclick="testEmptyWorkspaceQuery()">Test Empty Workspace Query</button>
    <button onclick="testReembedEmptyWorkspace()">Test Reembed Empty Workspace</button>
    <button onclick="testLargeContent()">Test Large Content (10k+ tokens)</button>
    <button onclick="testConcurrentRequests()">Test Concurrent Requests</button>
    <button onclick="testPDFLocatorLabels()">Test PDF Locator Labels</button>
    <button onclick="testReembedWorkspaceFilter()">Test Reembed Workspace Filter</button>
    <button onclick="testReembedDocIdFilter()">Test Reembed Doc ID Filter</button>
    <button onclick="testPublishedAtNullHandling()">Test Published_at Null Filter</button>
    <button onclick="testJobFailureCapture()">Test Job Failure Capture</button>
    <button onclick="testLanguageField()">Test Language Field</button>
    <div class="result">
        <h3>Result:</h3>
        <pre id="result">Click a button to test</pre>
    </div>

    <script>
        const BASE_URL = 'http://localhost:8000';

        async function checkHealth() {
            try {
                const res = await fetch(`${BASE_URL}/health`);
                const data = await res.json();
                document.getElementById('result').textContent = JSON.stringify(data, null, 2);
            } catch(e) {
                document.getElementById('result').textContent = 'Error: ' + e.message;
            }
        }

        async function testIngest() {
            const payload = {
                "workspace_id": "00000000-0000-0000-0000-000000000001",
                "idempotency_key": "test-" + Date.now(),
                "source": {
                    "url": "https://example.com/test-" + Date.now(),
                    "type": "article"
                },
                "content": "The Federal Reserve has announced a significant change in monetary policy. Chairman Powell discussed the implications for AAPL, GOOGL, and MSFT stock prices. The interest rate decision will impact the macro economic outlook. Inflation concerns remain elevated while employment data shows resilience.",
                "metadata": {
                    "title": "Fed Policy Analysis",
                    "author": "Test Author"
                }
            };

            document.getElementById('result').textContent = 'Sending request...';

            try {
                const res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await res.json();
                document.getElementById('result').textContent = 'Status: ' + res.status + '\n\n' + JSON.stringify(data, null, 2);
            } catch(e) {
                document.getElementById('result').textContent = 'Error: ' + e.message;
            }
        }

        async function testDuplicateIngest() {
            // Use fixed URL to test unique constraint
            const payload = {
                "workspace_id": "00000000-0000-0000-0000-000000000001",
                "source": {
                    "url": "https://example.com/duplicate-test-fixed",
                    "type": "article"
                },
                "content": "This is a test document for unique constraint testing.",
                "metadata": {
                    "title": "Duplicate Test",
                    "author": "Test Author"
                }
            };

            document.getElementById('result').textContent = 'Sending first request...';

            try {
                // First request
                let res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                let data1 = await res.json();

                // Second request with same URL
                document.getElementById('result').textContent = 'Sending second request (duplicate)...';
                res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                let data2 = await res.json();

                document.getElementById('result').textContent =
                    'First Request:\nStatus: ' + res.status + '\n' + JSON.stringify(data1, null, 2) +
                    '\n\nSecond Request (duplicate):\nStatus: ' + res.status + '\n' + JSON.stringify(data2, null, 2);
            } catch(e) {
                document.getElementById('result').textContent = 'Error: ' + e.message;
            }
        }

        async function testQuery() {
            const payload = {
                "workspace_id": "00000000-0000-0000-0000-000000000001",
                "question": "What did the Federal Reserve announce?",
                "mode": "answer",
                "top_k": 5
            };

            document.getElementById('result').textContent = 'Sending query...';

            try {
                const res = await fetch(`${BASE_URL}/query`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await res.json();
                document.getElementById('result').textContent = 'Status: ' + res.status + '\n\n' + JSON.stringify(data, null, 2);
            } catch(e) {
                document.getElementById('result').textContent = 'Error: ' + e.message;
            }
        }

        async function checkChunkVectors() {
            document.getElementById('result').textContent = 'Fetching chunk_vectors...';
            try {
                const res = await fetch(`${BASE_URL}/debug/chunk_vectors`);
                const data = await res.json();
                document.getElementById('result').textContent = 'Status: ' + res.status + '\n\n' + JSON.stringify(data, null, 2);
            } catch(e) {
                document.getElementById('result').textContent = 'Error: ' + e.message;
            }
        }

        async function checkDocuments() {
            document.getElementById('result').textContent = 'Fetching documents...';
            try {
                const res = await fetch(`${BASE_URL}/debug/documents`);
                const data = await res.json();
                document.getElementById('result').textContent = 'Status: ' + res.status + '\n\n' + JSON.stringify(data, null, 2);
            } catch(e) {
                document.getElementById('result').textContent = 'Error: ' + e.message;
            }
        }

        async function checkChunks() {
            document.getElementById('result').textContent = 'Fetching chunks...';
            try {
                const res = await fetch(`${BASE_URL}/debug/chunks`);
                const data = await res.json();
                document.getElementById('result').textContent = 'Status: ' + res.status + '\n\n' + JSON.stringify(data, null, 2);
            } catch(e) {
                document.getElementById('result').textContent = 'Error: ' + e.message;
            }
        }

        async function testYouTubeIngest() {
            // Test with a TED talk video known to have transcripts
            const payload = {
                "workspace_id": "00000000-0000-0000-0000-000000000001",
                "url": "https://www.youtube.com/watch?v=dQw4w9WgXcQ"
            };

            document.getElementById('result').textContent = 'Testing YouTube ingestion...';

            try {
                const res = await fetch(`${BASE_URL}/sources/youtube/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await res.json();
                document.getElementById('result').textContent = 'Status: ' + res.status + '\n\n' + JSON.stringify(data, null, 2);
            } catch(e) {
                document.getElementById('result').textContent = 'Error: ' + e.message;
            }
        }

        async function testReembed() {
            const payload = {
                "workspace_id": "00000000-0000-0000-0000-000000000001",
                "target_collection": "kb_nomic_embed_text_v2",
                "embed_provider": "ollama",
                "embed_model": "nomic-embed-text"
            };

            document.getElementById('result').textContent = 'Testing reembed...';

            try {
                const res = await fetch(`${BASE_URL}/reembed`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await res.json();
                const jobId = data.job_id;

                let output = 'Reembed Response:\nStatus: ' + res.status + '\n' + JSON.stringify(data, null, 2);

                // If job created, poll for status
                if (jobId) {
                    output += '\n\n--- Polling job status ---';
                    for (let i = 0; i < 5; i++) {
                        await new Promise(r => setTimeout(r, 2000));
                        const jobRes = await fetch(`${BASE_URL}/jobs/${jobId}`);
                        const jobData = await jobRes.json();
                        output += `\n\nPoll ${i+1}:\n` + JSON.stringify(jobData, null, 2);
                        if (jobData.status === 'completed' || jobData.status === 'failed') break;
                    }
                }

                document.getElementById('result').textContent = output;
            } catch(e) {
                document.getElementById('result').textContent = 'Error: ' + e.message;
            }
        }

        async function testWorkspaceIsolation() {
            const WORKSPACE_A = "00000000-0000-0000-0000-000000000001";
            let WORKSPACE_B = null;  // Will be set from workspace creation response
            let output = "=== WORKSPACE ISOLATION TEST ===\n\n";

            document.getElementById('result').textContent = 'Step 1: Creating second workspace...';

            try {
                // Step 1: Create second workspace
                let res = await fetch(`${BASE_URL}/debug/workspaces`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: "Test Workspace B",
                        slug: "test-workspace-b"
                    })
                });
                let data = await res.json();
                output += "Step 1 - Create Workspace B:\n" + JSON.stringify(data, null, 2) + "\n\n";

                // Get the actual workspace ID from the response
                if (data.success && data.workspace && data.workspace.id) {
                    WORKSPACE_B = data.workspace.id;
                    output += "Using Workspace B ID: " + WORKSPACE_B + "\n\n";
                } else {
                    output += "ERROR: Could not get workspace B ID\n\n";
                    document.getElementById('result').textContent = output;
                    return;
                }

                // Step 2: Ingest document into Workspace A
                document.getElementById('result').textContent = 'Step 2: Ingesting to Workspace A...';
                const docA = {
                    "workspace_id": WORKSPACE_A,
                    "idempotency_key": "isolation-test-a-" + Date.now(),
                    "source": {
                        "url": "https://example.com/workspace-a-doc-" + Date.now(),
                        "type": "article"
                    },
                    "content": "Workspace A unique content about Bitcoin and cryptocurrency markets. BTC price analysis shows strong momentum.",
                    "metadata": {
                        "title": "Workspace A Document"
                    }
                };
                res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(docA)
                });
                data = await res.json();
                output += "Step 2 - Ingest to Workspace A:\nStatus: " + res.status + "\n" + JSON.stringify(data, null, 2) + "\n\n";

                // Step 3: Ingest document into Workspace B
                document.getElementById('result').textContent = 'Step 3: Ingesting to Workspace B...';
                const docB = {
                    "workspace_id": WORKSPACE_B,
                    "idempotency_key": "isolation-test-b-" + Date.now(),
                    "source": {
                        "url": "https://example.com/workspace-b-doc-" + Date.now(),
                        "type": "article"
                    },
                    "content": "Workspace B unique content about Ethereum and smart contracts. ETH development updates and roadmap.",
                    "metadata": {
                        "title": "Workspace B Document"
                    }
                };
                res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(docB)
                });
                data = await res.json();
                output += "Step 3 - Ingest to Workspace B:\nStatus: " + res.status + "\n" + JSON.stringify(data, null, 2) + "\n\n";

                // Wait for embedding to complete
                await new Promise(r => setTimeout(r, 2000));

                // Step 4: Query Workspace A
                document.getElementById('result').textContent = 'Step 4: Querying Workspace A...';
                res = await fetch(`${BASE_URL}/query`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        "workspace_id": WORKSPACE_A,
                        "question": "Tell me about cryptocurrency",
                        "mode": "retrieve",
                        "top_k": 10
                    })
                });
                data = await res.json();
                output += "Step 4 - Query Workspace A:\nStatus: " + res.status + "\n";
                output += "Results count: " + (data.results ? data.results.length : 0) + "\n";
                if (data.results && data.results.length > 0) {
                    const workspaceIds = data.results.map(r => r.workspace_id || "N/A");
                    output += "Result workspace_ids: " + JSON.stringify(workspaceIds) + "\n";
                    // Check if all results are from Workspace A
                    const allFromA = data.results.every(r => r.workspace_id === WORKSPACE_A);
                    output += "All results from Workspace A: " + allFromA + "\n";
                }
                output += JSON.stringify(data, null, 2) + "\n\n";

                // Step 5: Query Workspace B
                document.getElementById('result').textContent = 'Step 5: Querying Workspace B...';
                res = await fetch(`${BASE_URL}/query`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        "workspace_id": WORKSPACE_B,
                        "question": "Tell me about cryptocurrency",
                        "mode": "retrieve",
                        "top_k": 10
                    })
                });
                data = await res.json();
                output += "Step 5 - Query Workspace B:\nStatus: " + res.status + "\n";
                output += "Results count: " + (data.results ? data.results.length : 0) + "\n";
                if (data.results && data.results.length > 0) {
                    const workspaceIds = data.results.map(r => r.workspace_id || "N/A");
                    output += "Result workspace_ids: " + JSON.stringify(workspaceIds) + "\n";
                    // Check if all results are from Workspace B
                    const allFromB = data.results.every(r => r.workspace_id === WORKSPACE_B);
                    output += "All results from Workspace B: " + allFromB + "\n";
                }
                output += JSON.stringify(data, null, 2) + "\n\n";

                output += "=== TEST COMPLETE ===\n";
                output += "Check that results from Workspace A query contain only Workspace A data,\n";
                output += "and results from Workspace B query contain only Workspace B data.";

                document.getElementById('result').textContent = output;
            } catch(e) {
                document.getElementById('result').textContent = output + '\n\nError: ' + e.message;
            }
        }

        async function testEmptyWorkspaceQuery() {
            let output = "=== EMPTY WORKSPACE QUERY TEST ===\n\n";
            document.getElementById('result').textContent = 'Step 1: Creating empty workspace...';

            try {
                // Step 1: Create a new empty workspace
                const timestamp = Date.now();
                let res = await fetch(`${BASE_URL}/debug/workspaces`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: "Empty Workspace " + timestamp,
                        slug: "empty-workspace-" + timestamp
                    })
                });
                let data = await res.json();
                output += "Step 1 - Create Empty Workspace:\n" + JSON.stringify(data, null, 2) + "\n\n";

                if (!data.success || !data.workspace || !data.workspace.id) {
                    output += "ERROR: Could not create workspace\n";
                    document.getElementById('result').textContent = output;
                    return;
                }

                const emptyWorkspaceId = data.workspace.id;
                output += "Created workspace ID: " + emptyWorkspaceId + "\n\n";

                // Step 2: Query the empty workspace
                document.getElementById('result').textContent = 'Step 2: Querying empty workspace...';
                const startTime = performance.now();
                res = await fetch(`${BASE_URL}/query`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        "workspace_id": emptyWorkspaceId,
                        "question": "What is the meaning of life?",
                        "mode": "retrieve",
                        "top_k": 10
                    })
                });
                const endTime = performance.now();
                const responseTime = endTime - startTime;
                data = await res.json();

                output += "Step 2 - Query Empty Workspace:\n";
                output += "HTTP Status: " + res.status + "\n";
                output += "Response time: " + responseTime.toFixed(2) + "ms\n";
                output += "Results count: " + (data.results ? data.results.length : "N/A") + "\n";
                output += "Response:\n" + JSON.stringify(data, null, 2) + "\n\n";

                // Verify results
                output += "=== VERIFICATION ===\n";
                const isStatus200 = res.status === 200;
                const isResultsEmpty = data.results && data.results.length === 0;
                const isNoError = !data.error && !data.detail;
                const isFast = responseTime < 2000;  // Less than 2 seconds

                output += "Status is 200: " + isStatus200 + "\n";
                output += "Results array is empty: " + isResultsEmpty + "\n";
                output += "No error raised: " + isNoError + "\n";
                output += "Response time < 2s: " + isFast + " (" + responseTime.toFixed(2) + "ms)\n";
                output += "\n=== TEST " + (isStatus200 && isResultsEmpty && isNoError && isFast ? "PASSED" : "FAILED") + " ===\n";

                document.getElementById('result').textContent = output;
            } catch(e) {
                document.getElementById('result').textContent = output + '\n\nError: ' + e.message;
            }
        }

        async function testReembedEmptyWorkspace() {
            let output = "=== REEMBED EMPTY WORKSPACE TEST ===\n\n";
            document.getElementById('result').textContent = 'Step 1: Creating empty workspace...';

            try {
                // Step 1: Create a new empty workspace
                const timestamp = Date.now();
                let res = await fetch(`${BASE_URL}/debug/workspaces`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: "Reembed Test Workspace " + timestamp,
                        slug: "reembed-test-" + timestamp
                    })
                });
                let data = await res.json();
                output += "Step 1 - Create Empty Workspace:\n" + JSON.stringify(data, null, 2) + "\n\n";

                if (!data.success || !data.workspace || !data.workspace.id) {
                    output += "ERROR: Could not create workspace\n";
                    document.getElementById('result').textContent = output;
                    return;
                }

                const emptyWorkspaceId = data.workspace.id;
                output += "Created workspace ID: " + emptyWorkspaceId + "\n\n";

                // Step 2: POST /reembed for this empty workspace
                document.getElementById('result').textContent = 'Step 2: Requesting reembed for empty workspace...';
                res = await fetch(`${BASE_URL}/reembed`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        "workspace_id": emptyWorkspaceId,
                        "target_collection": "kb_nomic_embed_text_v2",
                        "embed_provider": "ollama",
                        "embed_model": "nomic-embed-text"
                    })
                });
                data = await res.json();
                output += "Step 2 - Reembed Request:\n";
                output += "HTTP Status: " + res.status + "\n";
                output += "Response:\n" + JSON.stringify(data, null, 2) + "\n\n";

                const jobId = data.job_id;
                if (!jobId) {
                    output += "=== VERIFICATION ===\n";
                    output += "No job_id returned - checking if this is handled gracefully\n";
                    const isGraceful = res.status === 200 || res.status === 201;
                    output += "Request completed gracefully: " + isGraceful + "\n";
                    output += "\n=== TEST " + (isGraceful ? "PASSED" : "FAILED") + " ===\n";
                    document.getElementById('result').textContent = output;
                    return;
                }

                // Step 3: Poll job status
                document.getElementById('result').textContent = 'Step 3: Polling job status...';
                let jobStatus = null;
                for (let i = 0; i < 10; i++) {
                    await new Promise(r => setTimeout(r, 1000));
                    res = await fetch(`${BASE_URL}/jobs/${jobId}`);
                    data = await res.json();
                    output += "Poll " + (i+1) + ":\n" + JSON.stringify(data, null, 2) + "\n";

                    if (data.status === 'completed' || data.status === 'failed') {
                        jobStatus = data;
                        break;
                    }
                }

                output += "\n=== VERIFICATION ===\n";
                const isCompleted = jobStatus && jobStatus.status === 'completed';
                const hasZeroChunks = jobStatus && (jobStatus.chunks_queued === 0 || jobStatus.progress === 0);
                output += "Job completed successfully: " + isCompleted + "\n";
                output += "Chunks queued is 0 or progress is 0: " + hasZeroChunks + "\n";
                output += "\n=== TEST " + (isCompleted ? "PASSED" : "FAILED") + " ===\n";

                document.getElementById('result').textContent = output;
            } catch(e) {
                document.getElementById('result').textContent = output + '\n\nError: ' + e.message;
            }
        }

        async function testLargeContent() {
            let output = "=== LARGE CONTENT INGESTION TEST (10000+ tokens) ===\n\n";
            document.getElementById('result').textContent = 'Generating large content (10000+ tokens)...';

            try {
                // Generate content with 10000+ tokens (approximately 40000+ characters)
                // Each paragraph is about 100 words (~133 tokens)
                const baseParagraphs = [
                    "The Federal Reserve announced significant changes to monetary policy affecting global markets. Chairman Powell emphasized the importance of maintaining price stability while supporting maximum employment. Interest rate decisions will be data-dependent, with careful monitoring of inflation indicators and labor market conditions. The committee remains vigilant about upside risks to inflation and is prepared to adjust policy stance as appropriate. Financial conditions have tightened considerably over the past year, and the full effects of policy tightening are yet to be felt.",
                    "Apple Inc (AAPL) reported strong quarterly earnings, beating analyst expectations on both revenue and earnings per share. The company's services segment showed remarkable growth, contributing significantly to overall revenue. iPhone sales remained robust despite challenging macroeconomic conditions. Management provided optimistic guidance for the upcoming quarter, citing strong demand for premium devices. The stock rallied following the earnings announcement, reaching new all-time highs.",
                    "Microsoft Corporation (MSFT) continues to dominate the cloud computing market with Azure showing impressive growth rates. The company's artificial intelligence initiatives are gaining traction across enterprise customers. Office 365 subscription revenue grew steadily, demonstrating strong recurring revenue streams. Gaming division performed well with Xbox Game Pass subscriber growth accelerating. Management highlighted significant investments in AI infrastructure and partnerships.",
                    "Google (GOOGL) faces increased regulatory scrutiny as antitrust investigations continue globally. Search advertising revenue showed resilience despite competitive pressures from social media platforms. YouTube's advertising business demonstrated strong performance with increased watch time. Cloud Platform growth remained robust, though still trailing competitors in market share. The company announced ambitious AI product roadmaps across consumer and enterprise segments.",
                    "Amazon (AMZN) navigates challenging retail environment while AWS continues to drive profitability. E-commerce growth normalized after pandemic-driven surge, leading to operational efficiency measures. Third-party seller services showed healthy growth, contributing to marketplace ecosystem strength. Prime membership retention remained strong with expanded benefits and content offerings. Management emphasizes long-term investments in logistics and fulfillment capabilities.",
                    "Tesla (TSLA) expands production capacity with new gigafactories coming online globally. Electric vehicle demand remains strong despite increasing competition from traditional automakers. Energy storage and solar businesses show promising growth trajectories. Full self-driving technology continues to progress through beta testing phases. The company maintains cost leadership through vertical integration and manufacturing innovations.",
                    "NVIDIA (NVDA) dominates AI chip market with unprecedented demand for data center GPUs. Gaming segment performs well with new graphics card generations driving upgrade cycles. Automotive business shows steady growth with autonomous driving partnerships expanding. Data center revenue exceeds expectations as AI training workloads surge. Management projects continued strong demand from cloud service providers and enterprises.",
                    "Meta Platforms (META) focuses on metaverse investments while maintaining advertising revenue strength. Instagram Reels shows strong engagement competing effectively with TikTok platform. Reality Labs division continues significant investments despite ongoing losses. AI-driven content recommendations improve user engagement metrics across platforms. Advertising efficiency tools help small businesses optimize marketing spend.",
                    "Netflix (NFLX) adapts to streaming market maturation with ad-supported tier launch. Content investment strategy shifts toward quality over quantity approach. Password sharing crackdown shows initial positive impact on subscriber growth. International expansion continues with localized content production increasing. The company explores gaming and live events as growth vectors.",
                    "JPMorgan Chase (JPM) benefits from rising interest rate environment boosting net interest income. Investment banking activity remains subdued amid market volatility and uncertainty. Consumer banking shows resilience with strong deposit growth and loan demand. Credit quality metrics remain healthy despite economic headwinds concerns. Management maintains cautious outlook on commercial real estate exposure."
                ];

                // Repeat paragraphs to get to 10000+ tokens (need about 75+ paragraphs)
                let largeContent = "";
                for (let i = 0; i < 80; i++) {
                    const paragraph = baseParagraphs[i % baseParagraphs.length];
                    // Add variation to prevent exact duplicates
                    largeContent += `[Section ${i + 1}] ${paragraph} Market conditions as of iteration ${i + 1} show continued volatility.\n\n`;
                }

                const estimatedTokens = Math.ceil(largeContent.length / 4);  // Rough estimate: 4 chars per token
                output += `Generated content length: ${largeContent.length} characters\n`;
                output += `Estimated tokens: ~${estimatedTokens}\n\n`;

                const payload = {
                    "workspace_id": "00000000-0000-0000-0000-000000000001",
                    "idempotency_key": "large-content-test-" + Date.now(),
                    "source": {
                        "url": "https://example.com/large-document-" + Date.now(),
                        "type": "article"
                    },
                    "content": largeContent,
                    "metadata": {
                        "title": "Large Content Test Document",
                        "author": "Test Author"
                    }
                };

                document.getElementById('result').textContent = 'Sending large content request...';
                output += "Sending request to /ingest...\n";

                const startTime = performance.now();
                const res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const endTime = performance.now();
                const duration = (endTime - startTime) / 1000;  // Convert to seconds

                const data = await res.json();

                output += `\nResponse received!\n`;
                output += `HTTP Status: ${res.status}\n`;
                output += `Duration: ${duration.toFixed(2)} seconds\n`;
                output += `Response:\n${JSON.stringify(data, null, 2)}\n\n`;

                // Verification
                output += "=== VERIFICATION ===\n";
                const isSuccess = res.status === 200 || res.status === 201;
                const hasDocId = !!data.doc_id;
                const hasChunks = data.chunks_created > 0;
                const isWithinTime = duration < 60;  // Should complete within 60 seconds
                const hasMultipleChunks = data.chunks_created >= 10;  // Large content should create many chunks

                output += `Request successful (200/201): ${isSuccess}\n`;
                output += `Has doc_id: ${hasDocId}\n`;
                output += `Created chunks: ${data.chunks_created}\n`;
                output += `Has multiple chunks (>=10): ${hasMultipleChunks}\n`;
                output += `Created vectors: ${data.vectors_created}\n`;
                output += `Completed within 60s: ${isWithinTime} (${duration.toFixed(2)}s)\n`;

                const testPassed = isSuccess && hasDocId && hasMultipleChunks && isWithinTime;
                output += `\n=== TEST ${testPassed ? "PASSED" : "FAILED"} ===\n`;

                document.getElementById('result').textContent = output;
            } catch(e) {
                document.getElementById('result').textContent = output + '\n\nError: ' + e.message;
            }
        }

        async function testConcurrentRequests() {
            let output = "=== CONCURRENT REQUESTS TEST ===\n\n";
            document.getElementById('result').textContent = 'Preparing 10 concurrent requests...';

            try {
                const CONCURRENT_COUNT = 10;
                const requests = [];

                // Prepare 10 different payloads
                for (let i = 0; i < CONCURRENT_COUNT; i++) {
                    const timestamp = Date.now();
                    requests.push({
                        "workspace_id": "00000000-0000-0000-0000-000000000001",
                        "idempotency_key": `concurrent-test-${timestamp}-${i}`,
                        "source": {
                            "url": `https://example.com/concurrent-${timestamp}-${i}`,
                            "type": "article"
                        },
                        "content": `Concurrent test document ${i + 1}. This tests the service's ability to handle multiple simultaneous ingestion requests. Each document contains unique content about request number ${i + 1} with different metadata to ensure proper isolation. Stock symbols mentioned: AAPL, MSFT, GOOGL.`,
                        "metadata": {
                            "title": `Concurrent Test ${i + 1}`,
                            "author": `Author ${i + 1}`
                        }
                    });
                }

                output += `Prepared ${CONCURRENT_COUNT} requests\n\n`;
                document.getElementById('result').textContent = 'Sending 10 concurrent requests...';

                const startTime = performance.now();

                // Send all requests concurrently
                const promises = requests.map((payload, index) =>
                    fetch(`${BASE_URL}/ingest`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    }).then(async res => {
                        const data = await res.json();
                        return { index, status: res.status, data };
                    }).catch(err => {
                        return { index, status: 'error', error: err.message };
                    })
                );

                const results = await Promise.all(promises);
                const endTime = performance.now();
                const totalDuration = (endTime - startTime) / 1000;

                output += "=== RESULTS ===\n\n";

                let successCount = 0;
                let errorCount = 0;
                const docIds = new Set();

                results.forEach(result => {
                    output += `Request ${result.index + 1}: `;
                    if (result.status === 200 || result.status === 201) {
                        successCount++;
                        if (result.data.doc_id) {
                            docIds.add(result.data.doc_id);
                        }
                        output += `Status ${result.status}, doc_id: ${result.data.doc_id}, chunks: ${result.data.chunks_created}\n`;
                    } else if (result.status === 'error') {
                        errorCount++;
                        output += `ERROR: ${result.error}\n`;
                    } else {
                        errorCount++;
                        output += `Status ${result.status}: ${JSON.stringify(result.data)}\n`;
                    }
                });

                output += `\nTotal duration: ${totalDuration.toFixed(2)} seconds\n`;
                output += `Average per request: ${(totalDuration / CONCURRENT_COUNT).toFixed(2)} seconds\n\n`;

                // Verification
                output += "=== VERIFICATION ===\n";
                const allSucceeded = successCount === CONCURRENT_COUNT;
                const noErrors = errorCount === 0;
                const uniqueDocIds = docIds.size === CONCURRENT_COUNT;
                const reasonableTime = totalDuration < 60;

                output += `All requests succeeded: ${allSucceeded} (${successCount}/${CONCURRENT_COUNT})\n`;
                output += `No errors: ${noErrors}\n`;
                output += `Unique doc_ids: ${uniqueDocIds} (${docIds.size}/${CONCURRENT_COUNT})\n`;
                output += `Completed within 60s: ${reasonableTime} (${totalDuration.toFixed(2)}s)\n`;

                const testPassed = allSucceeded && noErrors && uniqueDocIds && reasonableTime;
                output += `\n=== TEST ${testPassed ? "PASSED" : "FAILED"} ===\n`;

                document.getElementById('result').textContent = output;
            } catch(e) {
                document.getElementById('result').textContent = output + '\n\nError: ' + e.message;
            }
        }

        async function testPDFLocatorLabels() {
            let output = "=== PDF LOCATOR LABELS AND PAGE SPANS TEST ===\n\n";
            document.getElementById('result').textContent = 'Testing PDF with page information...';

            try {
                // Create PDF document with pre-chunked content including page numbers
                const timestamp = Date.now();
                const payload = {
                    "workspace_id": "00000000-0000-0000-0000-000000000001",
                    "idempotency_key": "pdf-page-test-" + timestamp,
                    "source": {
                        "url": "https://example.com/test-pdf-pages-" + timestamp + ".pdf",
                        "type": "pdf"
                    },
                    "content": "Full document content placeholder for PDF testing.",
                    "metadata": {
                        "title": "PDF Page Test Document",
                        "author": "Test PDF Author"
                    },
                    "chunks": [
                        {
                            "content": "This is page 1 content about market analysis and introduction to trading strategies.",
                            "page_start": 1,
                            "page_end": 1
                        },
                        {
                            "content": "Page 2 covers detailed analysis of stock performance metrics and valuation methods.",
                            "page_start": 2,
                            "page_end": 2
                        },
                        {
                            "content": "This chunk spans pages 3 to 5 covering comprehensive risk management approaches, portfolio diversification strategies, and advanced hedging techniques across multiple chapters.",
                            "page_start": 3,
                            "page_end": 5
                        },
                        {
                            "content": "Pages 6 through 7 discuss regulatory compliance and market structure considerations.",
                            "page_start": 6,
                            "page_end": 7
                        }
                    ]
                };

                output += "Sending pre-chunked PDF request with page info...\n\n";

                const res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await res.json();

                output += "Ingest Response:\n";
                output += `HTTP Status: ${res.status}\n`;
                output += `Doc ID: ${data.doc_id}\n`;
                output += `Chunks Created: ${data.chunks_created}\n`;
                output += `Vectors Created: ${data.vectors_created}\n`;
                output += `Status: ${data.status}\n\n`;

                if (data.status === 'exists') {
                    output += "Note: Document already exists. Using existing doc_id.\n\n";
                }

                // Fetch chunks with page info
                output += "Fetching chunks with page info...\n";
                const chunksRes = await fetch(`${BASE_URL}/debug/chunks?doc_id=${data.doc_id}`);
                const chunksData = await chunksRes.json();

                output += `\nFound ${chunksData.count} chunks:\n\n`;

                if (chunksData.success && chunksData.chunks) {
                    chunksData.chunks.forEach((chunk, i) => {
                        output += `Chunk ${i + 1}:\n`;
                        output += `  chunk_index: ${chunk.chunk_index}\n`;
                        output += `  page_start: ${chunk.page_start}\n`;
                        output += `  page_end: ${chunk.page_end}\n`;
                        output += `  locator_label: "${chunk.locator_label}"\n`;
                        output += `  content: "${chunk.content_preview}..."\n\n`;
                    });

                    // Verification
                    output += "=== VERIFICATION ===\n\n";

                    // Test 1: Locator label for single page uses "p. X" format
                    const singlePageChunks = chunksData.chunks.filter(c => c.page_start === c.page_end && c.page_start !== null);
                    const singlePageLabelsCorrect = singlePageChunks.every(c => c.locator_label && c.locator_label.startsWith("p. "));
                    output += `Test 1 - Single page uses 'p. X' format: ${singlePageLabelsCorrect}\n`;
                    if (singlePageChunks.length > 0) {
                        output += `  Examples: ${singlePageChunks.map(c => c.locator_label).join(", ")}\n`;
                    }

                    // Test 2: Multi-page spans use "pp. X-Y" format
                    const multiPageChunks = chunksData.chunks.filter(c => c.page_start !== null && c.page_end !== null && c.page_end > c.page_start);
                    const multiPageLabelsCorrect = multiPageChunks.every(c => c.locator_label && c.locator_label.startsWith("pp. "));
                    output += `\nTest 2 - Multi-page spans use 'pp. X-Y' format: ${multiPageLabelsCorrect}\n`;
                    if (multiPageChunks.length > 0) {
                        output += `  Examples: ${multiPageChunks.map(c => c.locator_label).join(", ")}\n`;
                    }

                    // Test 3: Page numbers are stored correctly
                    const chunk3 = chunksData.chunks.find(c => c.page_start === 3 && c.page_end === 5);
                    const pageSpanCorrect = chunk3 !== undefined;
                    output += `\nTest 3 - Page span (3-5) tracked correctly: ${pageSpanCorrect}\n`;
                    if (chunk3) {
                        output += `  page_start: ${chunk3.page_start}, page_end: ${chunk3.page_end}\n`;
                    }

                    const allTestsPassed = singlePageLabelsCorrect && multiPageLabelsCorrect && pageSpanCorrect;
                    output += `\n=== TEST ${allTestsPassed ? "PASSED" : "FAILED"} ===\n`;
                } else {
                    output += "Error fetching chunks: " + JSON.stringify(chunksData) + "\n";
                    output += "\n=== TEST FAILED ===\n";
                }

                document.getElementById('result').textContent = output;
            } catch(e) {
                document.getElementById('result').textContent = output + '\n\nError: ' + e.message;
            }
        }

        async function testReembedWorkspaceFilter() {
            const WORKSPACE_A = "00000000-0000-0000-0000-000000000001";
            let WORKSPACE_B = null;
            let output = "=== REEMBED WORKSPACE FILTER TEST ===\n\n";
            document.getElementById('result').textContent = 'Starting test...';

            try {
                // Step 1: Create Workspace B if it doesn't exist
                document.getElementById('result').textContent = 'Step 1: Creating Workspace B...';
                let res = await fetch(`${BASE_URL}/debug/workspaces`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: "Reembed Test Workspace B",
                        slug: "reembed-test-workspace-b"
                    })
                });
                let data = await res.json();
                output += "Step 1 - Create/Get Workspace B:\n" + JSON.stringify(data, null, 2) + "\n\n";

                if (data.success && data.workspace && data.workspace.id) {
                    WORKSPACE_B = data.workspace.id;
                } else if (data.workspace_id) {
                    WORKSPACE_B = data.workspace_id;
                } else {
                    output += "ERROR: Could not get workspace B ID\n";
                    document.getElementById('result').textContent = output;
                    return;
                }
                output += "Using Workspace B ID: " + WORKSPACE_B + "\n\n";

                // Step 2: Ingest documents into both workspaces
                document.getElementById('result').textContent = 'Step 2: Ingesting documents...';
                const timestamp = Date.now();

                // Ingest to Workspace A
                const docA = {
                    "workspace_id": WORKSPACE_A,
                    "idempotency_key": "reembed-test-a-" + timestamp,
                    "source": { "url": "https://example.com/reembed-test-a-" + timestamp, "type": "article" },
                    "content": "Workspace A content for reembed filtering test. Contains unique data about alpha market analysis.",
                    "metadata": { "title": "Reembed Test A" }
                };
                res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(docA)
                });
                let resultA = await res.json();
                output += "Step 2a - Ingest to Workspace A:\n" + JSON.stringify(resultA, null, 2) + "\n\n";

                // Ingest to Workspace B
                const docB = {
                    "workspace_id": WORKSPACE_B,
                    "idempotency_key": "reembed-test-b-" + timestamp,
                    "source": { "url": "https://example.com/reembed-test-b-" + timestamp, "type": "article" },
                    "content": "Workspace B content for reembed filtering test. Contains unique data about beta strategy review.",
                    "metadata": { "title": "Reembed Test B" }
                };
                res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(docB)
                });
                let resultB = await res.json();
                output += "Step 2b - Ingest to Workspace B:\n" + JSON.stringify(resultB, null, 2) + "\n\n";

                // Wait for embeddings
                await new Promise(r => setTimeout(r, 2000));

                // Step 3: Get chunk counts using the count endpoint
                document.getElementById('result').textContent = 'Step 3: Counting chunks per workspace...';
                res = await fetch(`${BASE_URL}/debug/chunks/count?workspace_id=${WORKSPACE_A}`);
                let countAResult = await res.json();
                res = await fetch(`${BASE_URL}/debug/chunks/count?workspace_id=${WORKSPACE_B}`);
                let countBResult = await res.json();

                const countA = countAResult.success ? countAResult.count : 0;
                const countB = countBResult.success ? countBResult.count : 0;
                output += `Step 3 - Chunk counts (from count endpoint):\n`;
                output += `  Workspace A: ${countA} chunks\n`;
                output += `  Workspace B: ${countB} chunks\n\n`;

                // Step 4: Run reembed for Workspace A only
                document.getElementById('result').textContent = 'Step 4: Running reembed for Workspace A only...';
                const reembedPayload = {
                    "workspace_id": WORKSPACE_A,
                    "target_collection": "kb_reembed_test_v1_" + timestamp,
                    "embed_provider": "ollama",
                    "embed_model": "nomic-embed-text"
                };
                res = await fetch(`${BASE_URL}/reembed`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(reembedPayload)
                });
                let reembedResult = await res.json();
                output += "Step 4 - Reembed for Workspace A:\n" + JSON.stringify(reembedResult, null, 2) + "\n\n";

                // Step 5: Verify chunks_queued matches Workspace A count (not A+B)
                output += "=== VERIFICATION ===\n\n";
                const chunksQueuedMatchesA = reembedResult.chunks_queued === countA;
                const totalChunks = countA + countB;
                const notIncludingBoth = reembedResult.chunks_queued !== totalChunks || countB === 0;

                output += `Test 1 - Reembed only queues Workspace A chunks:\n`;
                output += `  chunks_queued: ${reembedResult.chunks_queued}\n`;
                output += `  Workspace A chunk count: ${countA}\n`;
                output += `  Workspace B chunk count: ${countB}\n`;
                output += `  Total chunks (A+B): ${totalChunks}\n`;
                output += `  Exact match with Workspace A: ${chunksQueuedMatchesA}\n`;
                output += `  Not including both workspaces: ${notIncludingBoth}\n\n`;

                // Step 6: Poll job status to verify completion
                if (reembedResult.job_id) {
                    document.getElementById('result').textContent = 'Step 5: Polling job status...';
                    for (let i = 0; i < 15; i++) {
                        await new Promise(r => setTimeout(r, 1000));
                        res = await fetch(`${BASE_URL}/jobs/${reembedResult.job_id}`);
                        let jobStatus = await res.json();
                        output += `Job poll ${i+1}: status=${jobStatus.status}, progress=${jobStatus.progress}%\n`;
                        if (jobStatus.status === 'completed' || jobStatus.status === 'failed') {
                            break;
                        }
                    }
                }

                // The key verification: chunks_queued should equal Workspace A count exactly
                // This proves that workspace filtering is working
                const testPassed = chunksQueuedMatchesA && reembedResult.chunks_queued > 0;
                output += `\n=== TEST ${testPassed ? "PASSED" : "FAILED"} ===\n`;
                if (testPassed) {
                    output += `SUCCESS: Reembed for Workspace A queued exactly ${reembedResult.chunks_queued} chunks,\n`;
                    output += `which matches the count of chunks in Workspace A (${countA}).\n`;
                    output += `Workspace B's ${countB} chunks were NOT included - workspace filtering works!\n`;
                } else {
                    output += `ISSUE: chunks_queued (${reembedResult.chunks_queued}) != Workspace A count (${countA})\n`;
                    output += `This could indicate a timing issue or workspace filtering problem.\n`;
                }

                document.getElementById('result').textContent = output;
            } catch(e) {
                document.getElementById('result').textContent = output + '\n\nError: ' + e.message;
            }
        }

        async function testReembedDocIdFilter() {
            const WORKSPACE_A = "00000000-0000-0000-0000-000000000001";
            let output = "=== REEMBED DOC_ID FILTER TEST ===\n\n";
            document.getElementById('result').textContent = 'Starting test...';

            try {
                const timestamp = Date.now();

                // Step 1: Ingest 3 documents
                document.getElementById('result').textContent = 'Step 1: Ingesting 3 documents...';
                const docs = [];
                for (let i = 1; i <= 3; i++) {
                    const payload = {
                        "workspace_id": WORKSPACE_A,
                        "idempotency_key": `docid-filter-test-${timestamp}-doc${i}`,
                        "source": { "url": `https://example.com/docid-test-${timestamp}-doc${i}`, "type": "article" },
                        "content": `Document ${i} content for doc_id filtering test. This is document number ${i} with unique content for testing purposes.`,
                        "metadata": { "title": `Doc ID Filter Test ${i}` }
                    };
                    const res = await fetch(`${BASE_URL}/ingest`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const data = await res.json();
                    docs.push({ index: i, doc_id: data.doc_id, chunks_created: data.chunks_created });
                    output += `Doc ${i}: doc_id=${data.doc_id}, chunks=${data.chunks_created}, status=${data.status}\n`;
                }
                output += "\n";

                // Wait for embeddings
                await new Promise(r => setTimeout(r, 2000));

                // Step 2: Count chunks per document
                document.getElementById('result').textContent = 'Step 2: Counting chunks per document...';
                let totalChunksSelected = 0;
                for (const doc of docs.slice(0, 2)) { // Only first 2 docs
                    const res = await fetch(`${BASE_URL}/debug/chunks?doc_id=${doc.doc_id}`);
                    const data = await res.json();
                    doc.chunk_count = data.count || 0;
                    totalChunksSelected += doc.chunk_count;
                    output += `Doc ${doc.index} (${doc.doc_id}): ${doc.chunk_count} chunks\n`;
                }
                // Count doc 3 chunks
                const res3 = await fetch(`${BASE_URL}/debug/chunks?doc_id=${docs[2].doc_id}`);
                const data3 = await res3.json();
                docs[2].chunk_count = data3.count || 0;
                output += `Doc 3 (${docs[2].doc_id}): ${docs[2].chunk_count} chunks (NOT selected)\n\n`;

                // Step 3: Run reembed with only doc_ids for doc1 and doc2
                document.getElementById('result').textContent = 'Step 3: Running reembed with doc_ids filter...';
                const reembedPayload = {
                    "workspace_id": WORKSPACE_A,
                    "target_collection": "kb_docid_test_v1_" + timestamp,
                    "embed_provider": "ollama",
                    "embed_model": "nomic-embed-text",
                    "doc_ids": [docs[0].doc_id, docs[1].doc_id]
                };
                const reembedRes = await fetch(`${BASE_URL}/reembed`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(reembedPayload)
                });
                const reembedResult = await reembedRes.json();
                output += "Reembed Response:\n" + JSON.stringify(reembedResult, null, 2) + "\n\n";

                // Step 4: Verify
                output += "=== VERIFICATION ===\n\n";
                const expectedChunks = docs[0].chunk_count + docs[1].chunk_count;
                const doc3Chunks = docs[2].chunk_count;
                const chunksQueuedMatchesSelected = reembedResult.chunks_queued === expectedChunks;
                const notIncludingDoc3 = reembedResult.chunks_queued !== (expectedChunks + doc3Chunks) || doc3Chunks === 0;

                output += `Doc 1 chunks: ${docs[0].chunk_count}\n`;
                output += `Doc 2 chunks: ${docs[1].chunk_count}\n`;
                output += `Expected total (doc1+doc2): ${expectedChunks}\n`;
                output += `Doc 3 chunks (not selected): ${doc3Chunks}\n`;
                output += `chunks_queued: ${reembedResult.chunks_queued}\n\n`;
                output += `Exact match with selected docs: ${chunksQueuedMatchesSelected}\n`;
                output += `Not including doc3: ${notIncludingDoc3}\n\n`;

                // Poll job status
                if (reembedResult.job_id) {
                    document.getElementById('result').textContent = 'Polling job status...';
                    for (let i = 0; i < 10; i++) {
                        await new Promise(r => setTimeout(r, 1000));
                        const jobRes = await fetch(`${BASE_URL}/jobs/${reembedResult.job_id}`);
                        const jobStatus = await jobRes.json();
                        output += `Job poll ${i+1}: status=${jobStatus.status}, progress=${jobStatus.progress}%\n`;
                        if (jobStatus.status === 'completed' || jobStatus.status === 'failed') break;
                    }
                }

                const testPassed = chunksQueuedMatchesSelected && reembedResult.chunks_queued > 0;
                output += `\n=== TEST ${testPassed ? "PASSED" : "FAILED"} ===\n`;
                if (testPassed) {
                    output += `SUCCESS: Reembed with doc_ids filter queued exactly ${reembedResult.chunks_queued} chunks\n`;
                    output += `matching the selected documents (doc1+doc2=${expectedChunks}).\n`;
                    output += `Doc 3's ${doc3Chunks} chunks were correctly excluded.\n`;
                }

                document.getElementById('result').textContent = output;
            } catch(e) {
                document.getElementById('result').textContent = output + '\n\nError: ' + e.message;
            }
        }

        async function testPublishedAtNullHandling() {
            const WORKSPACE_A = "00000000-0000-0000-0000-000000000001";
            let output = "=== PUBLISHED_AT NULL HANDLING IN FILTERS TEST ===\n\n";
            document.getElementById('result').textContent = 'Starting test...';

            try {
                const timestamp = Date.now();

                // Step 1: Ingest document WITHOUT published_at
                document.getElementById('result').textContent = 'Step 1: Ingesting document WITHOUT published_at...';
                const docWithoutDate = {
                    "workspace_id": WORKSPACE_A,
                    "idempotency_key": `null-published-test-${timestamp}`,
                    "source": { "url": `https://example.com/null-published-${timestamp}`, "type": "article" },
                    "content": "This document has NO published_at date. It discusses null date filtering test content about markets.",
                    "metadata": { "title": "Null Published_at Test" }
                    // Note: no published_at in metadata
                };
                let res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(docWithoutDate)
                });
                let result1 = await res.json();
                output += "Step 1 - Ingest WITHOUT published_at:\n" + JSON.stringify(result1, null, 2) + "\n\n";

                // Step 2: Ingest document WITH published_at (recent date)
                document.getElementById('result').textContent = 'Step 2: Ingesting document WITH published_at...';
                const docWithDate = {
                    "workspace_id": WORKSPACE_A,
                    "idempotency_key": `with-published-test-${timestamp}`,
                    "source": { "url": `https://example.com/with-published-${timestamp}`, "type": "article" },
                    "content": "This document HAS a published_at date set to 2024. It discusses date filtering test content about markets.",
                    "metadata": {
                        "title": "With Published_at Test",
                        "published_at": "2024-06-15T12:00:00Z"
                    }
                };
                res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(docWithDate)
                });
                let result2 = await res.json();
                output += "Step 2 - Ingest WITH published_at (2024-06-15):\n" + JSON.stringify(result2, null, 2) + "\n\n";

                // Wait for embeddings to complete
                await new Promise(r => setTimeout(r, 3000));

                // Step 3: Query WITHOUT date filter - should return both
                document.getElementById('result').textContent = 'Step 3: Query without date filter...';
                res = await fetch(`${BASE_URL}/query`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        "workspace_id": WORKSPACE_A,
                        "question": "date filtering test content",
                        "mode": "retrieve",
                        "top_k": 20
                    })
                });
                let queryNoFilter = await res.json();
                output += "Step 3 - Query WITHOUT date filter:\n";
                output += `Results count: ${queryNoFilter.results ? queryNoFilter.results.length : 0}\n`;

                // Check for both documents
                const hasNullDoc = queryNoFilter.results?.some(r => r.content?.includes("NO published_at"));
                const hasDateDoc = queryNoFilter.results?.some(r => r.content?.includes("HAS a published_at"));
                output += `Contains null-date doc: ${hasNullDoc}\n`;
                output += `Contains dated doc: ${hasDateDoc}\n\n`;

                // Step 4: Query WITH date range filter - should EXCLUDE null published_at docs
                document.getElementById('result').textContent = 'Step 4: Query with date range filter...';
                res = await fetch(`${BASE_URL}/query`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        "workspace_id": WORKSPACE_A,
                        "question": "date filtering test content",
                        "mode": "retrieve",
                        "top_k": 20,
                        "filters": {
                            "published_from": "2024-01-01",
                            "published_to": "2024-12-31"
                        }
                    })
                });
                let queryWithFilter = await res.json();
                output += "Step 4 - Query WITH date range filter (2024):\n";
                output += `Results count: ${queryWithFilter.results ? queryWithFilter.results.length : 0}\n`;

                // Check for documents
                const hasNullDocFiltered = queryWithFilter.results?.some(r => r.content?.includes("NO published_at"));
                const hasDateDocFiltered = queryWithFilter.results?.some(r => r.content?.includes("HAS a published_at"));
                output += `Contains null-date doc: ${hasNullDocFiltered}\n`;
                output += `Contains dated doc: ${hasDateDocFiltered}\n\n`;

                // Step 5: Verification
                output += "=== VERIFICATION ===\n\n";

                // Test criteria:
                // 1. Without filter: both documents should be found (or at least the dated one)
                // 2. With date filter: null published_at doc should be EXCLUDED

                const test1Passed = hasDateDoc; // At least dated doc found without filter
                const test2Passed = !hasNullDocFiltered; // Null doc excluded with filter
                const test3Passed = hasDateDocFiltered; // Dated doc included with filter

                output += `Test 1 - Dated doc found without filter: ${test1Passed}\n`;
                output += `Test 2 - Null-date doc EXCLUDED with date filter: ${test2Passed}\n`;
                output += `Test 3 - Dated doc INCLUDED with date filter: ${test3Passed}\n\n`;

                const allPassed = test1Passed && test2Passed && test3Passed;
                output += `\n=== TEST ${allPassed ? "PASSED" : "FAILED"} ===\n`;

                if (allPassed) {
                    output += "SUCCESS: Documents without published_at are correctly excluded\n";
                    output += "when date range filters are applied.\n";
                } else {
                    if (!test2Passed) {
                        output += "ISSUE: Document with null published_at was NOT excluded from date-filtered results.\n";
                        output += "This may indicate that null date handling needs to be implemented.\n";
                    }
                }

                document.getElementById('result').textContent = output;
            } catch(e) {
                document.getElementById('result').textContent = output + '\n\nError: ' + e.message;
            }
        }

        async function testJobFailureCapture() {
            let output = "=== JOB FAILURE CAPTURE TEST ===\n\n";
            document.getElementById('result').textContent = 'Starting test...';

            try {
                // Step 1: POST /reembed with invalid configuration
                // We'll use a non-existent workspace_id to trigger a failure
                document.getElementById('result').textContent = 'Step 1: POST /reembed with invalid workspace...';
                const invalidPayload = {
                    "workspace_id": "99999999-9999-9999-9999-999999999999",  // Non-existent workspace
                    "target_collection": "kb_invalid_test_collection",
                    "embed_provider": "ollama",
                    "embed_model": "nomic-embed-text"
                };

                let res = await fetch(`${BASE_URL}/reembed`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(invalidPayload)
                });
                let reembedResult = await res.json();
                output += "Step 1 - POST /reembed with non-existent workspace:\n";
                output += `HTTP Status: ${res.status}\n`;
                output += JSON.stringify(reembedResult, null, 2) + "\n\n";

                // Check if job was created or if there was an immediate error
                if (reembedResult.job_id) {
                    // Step 2: GET /jobs/{job_id}
                    document.getElementById('result').textContent = 'Step 2: Polling job status...';
                    let finalStatus = null;
                    let finalError = null;

                    for (let i = 0; i < 10; i++) {
                        await new Promise(r => setTimeout(r, 1000));
                        res = await fetch(`${BASE_URL}/jobs/${reembedResult.job_id}`);
                        let jobStatus = await res.json();
                        output += `Job poll ${i+1}: status=${jobStatus.status}, progress=${jobStatus.progress}%`;
                        if (jobStatus.error) {
                            output += `, error="${jobStatus.error}"`;
                            finalError = jobStatus.error;
                        }
                        output += "\n";
                        finalStatus = jobStatus.status;
                        if (jobStatus.status === 'completed' || jobStatus.status === 'failed') {
                            break;
                        }
                    }

                    output += "\n=== VERIFICATION ===\n\n";

                    // For a non-existent workspace, the job might complete with 0 chunks
                    // or fail - both are valid outcomes
                    const jobCompleted = finalStatus === 'completed' || finalStatus === 'failed';
                    output += `Test 1 - Job reached terminal state: ${jobCompleted} (status: ${finalStatus})\n`;

                    if (finalStatus === 'failed') {
                        const hasErrorInfo = finalError !== null && finalError.length > 0;
                        output += `Test 2 - Error field contains info: ${hasErrorInfo}\n`;
                        if (hasErrorInfo) {
                            output += `  Error: "${finalError}"\n`;
                        }
                        output += `\n=== TEST PASSED ===\n`;
                        output += `Job failure captured with error details.\n`;
                    } else if (finalStatus === 'completed' && reembedResult.chunks_queued === 0) {
                        output += `Test 2 - Job handled gracefully (0 chunks for non-existent workspace): true\n`;
                        output += `\n=== TEST PASSED (GRACEFUL HANDLING) ===\n`;
                        output += `Empty workspace handled gracefully without error.\n`;
                    } else {
                        output += `\n=== UNEXPECTED RESULT ===\n`;
                        output += `Status: ${finalStatus}, chunks_queued: ${reembedResult.chunks_queued}\n`;
                    }
                } else {
                    // Immediate error response
                    output += "\n=== VERIFICATION ===\n\n";
                    const hasDetail = reembedResult.detail !== undefined;
                    output += `Test 1 - Immediate error response received: true\n`;
                    output += `Test 2 - Error contains detail field: ${hasDetail}\n`;
                    if (hasDetail) {
                        output += `  Detail: "${reembedResult.detail}"\n`;
                    }
                    output += `\n=== TEST PASSED ===\n`;
                    output += `Error captured with useful information.\n`;
                }

                document.getElementById('result').textContent = output;
            } catch(e) {
                document.getElementById('result').textContent = output + '\n\nError: ' + e.message;
            }
        }

        async function testLanguageField() {
            const WORKSPACE_A = "00000000-0000-0000-0000-000000000001";
            let output = "=== LANGUAGE FIELD TEST ===\n\n";
            document.getElementById('result').textContent = 'Starting test...';

            try {
                const timestamp = Date.now();

                // Step 1: Ingest English document (default language)
                document.getElementById('result').textContent = 'Step 1: Ingesting English document (default)...';
                const docEn = {
                    "workspace_id": WORKSPACE_A,
                    "idempotency_key": `lang-test-en-${timestamp}`,
                    "source": { "url": `https://example.com/lang-test-en-${timestamp}`, "type": "article" },
                    "content": "This is an English document for language field testing. Hello world!",
                    "metadata": {
                        "title": "English Document Test"
                        // No explicit language - should default to 'en'
                    }
                };
                let res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(docEn)
                });
                let resultEn = await res.json();
                output += "Step 1 - Ingest English doc (no explicit language):\n";
                output += `HTTP Status: ${res.status}\n`;
                output += JSON.stringify(resultEn, null, 2) + "\n\n";

                // Step 2: Ingest Spanish document (explicit language)
                document.getElementById('result').textContent = 'Step 2: Ingesting Spanish document (explicit)...';
                const docEs = {
                    "workspace_id": WORKSPACE_A,
                    "idempotency_key": `lang-test-es-${timestamp}`,
                    "source": { "url": `https://example.com/lang-test-es-${timestamp}`, "type": "article" },
                    "content": "Este es un documento en espaol para la prueba de campo de idioma. Hola mundo!",
                    "metadata": {
                        "title": "Spanish Document Test",
                        "language": "es"  // Explicit Spanish
                    }
                };
                res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(docEs)
                });
                let resultEs = await res.json();
                output += "Step 2 - Ingest Spanish doc (language='es'):\n";
                output += `HTTP Status: ${res.status}\n`;
                output += JSON.stringify(resultEs, null, 2) + "\n\n";

                // Step 3: Fetch documents and verify language fields
                document.getElementById('result').textContent = 'Step 3: Fetching documents to verify language fields...';
                res = await fetch(`${BASE_URL}/debug/documents`);
                let docsData = await res.json();
                output += "Step 3 - Fetch documents:\n";

                // Find our test documents
                let enDoc = null;
                let esDoc = null;
                if (docsData.documents) {
                    enDoc = docsData.documents.find(d => d.id === resultEn.doc_id);
                    esDoc = docsData.documents.find(d => d.id === resultEs.doc_id);
                }

                output += `\nEnglish document found: ${enDoc !== null && enDoc !== undefined}\n`;
                if (enDoc) {
                    output += `  language field: "${enDoc.language}"\n`;
                }

                output += `Spanish document found: ${esDoc !== null && esDoc !== undefined}\n`;
                if (esDoc) {
                    output += `  language field: "${esDoc.language}"\n`;
                }

                output += "\n=== VERIFICATION ===\n\n";

                // Verify language fields
                const enLangCorrect = enDoc && enDoc.language === 'en';
                const esLangCorrect = esDoc && esDoc.language === 'es';

                output += `Test 1 - English doc has language='en': ${enLangCorrect}\n`;
                output += `Test 2 - Spanish doc has language='es': ${esLangCorrect}\n\n`;

                const allPassed = enLangCorrect && esLangCorrect;
                output += `\n=== TEST ${allPassed ? "PASSED" : "FAILED"} ===\n`;

                if (allPassed) {
                    output += "SUCCESS: Language field stored correctly for multi-language content.\n";
                    output += "- Default 'en' applied when not specified\n";
                    output += "- Explicit 'es' stored when provided\n";
                } else {
                    if (!enLangCorrect) {
                        output += "ISSUE: English document language field is not 'en'\n";
                    }
                    if (!esLangCorrect) {
                        output += "ISSUE: Spanish document language field is not 'es'\n";
                    }
                }

                document.getElementById('result').textContent = output;
            } catch(e) {
                document.getElementById('result').textContent = output + '\n\nError: ' + e.message;
            }
        }
    </script>
</body>
</html>
