<!DOCTYPE html>
<html>
<head>
    <title>API Test</title>
    <style>
        body { font-family: monospace; padding: 20px; }
        pre { background: #f0f0f0; padding: 10px; overflow: auto; max-height: 600px; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        .result { margin-top: 20px; }
    </style>
</head>
<body>
    <h1>RAG API Test</h1>
    <button onclick="testIngest()">Test Ingest</button>
    <button onclick="testQuery()">Test Query</button>
    <button onclick="checkHealth()">Check Health</button>
    <button onclick="checkChunkVectors()">Check Chunk Vectors</button>
    <button onclick="checkDocuments()">Check Documents</button>
    <button onclick="checkChunks()">Check Chunks</button>
    <button onclick="testDuplicateIngest()">Test Duplicate</button>
    <button onclick="testYouTubeIngest()">Test YouTube</button>
    <button onclick="testReembed()">Test Reembed</button>
    <button onclick="testWorkspaceIsolation()">Test Workspace Isolation</button>
    <button onclick="testEmptyWorkspaceQuery()">Test Empty Workspace Query</button>
    <button onclick="testReembedEmptyWorkspace()">Test Reembed Empty Workspace</button>
    <button onclick="testLargeContent()">Test Large Content (10k+ tokens)</button>
    <button onclick="testConcurrentRequests()">Test Concurrent Requests</button>
    <div class="result">
        <h3>Result:</h3>
        <pre id="result">Click a button to test</pre>
    </div>

    <script>
        const BASE_URL = 'http://localhost:8000';

        async function checkHealth() {
            try {
                const res = await fetch(`${BASE_URL}/health`);
                const data = await res.json();
                document.getElementById('result').textContent = JSON.stringify(data, null, 2);
            } catch(e) {
                document.getElementById('result').textContent = 'Error: ' + e.message;
            }
        }

        async function testIngest() {
            const payload = {
                "workspace_id": "00000000-0000-0000-0000-000000000001",
                "idempotency_key": "test-" + Date.now(),
                "source": {
                    "url": "https://example.com/test-" + Date.now(),
                    "type": "article"
                },
                "content": "The Federal Reserve has announced a significant change in monetary policy. Chairman Powell discussed the implications for AAPL, GOOGL, and MSFT stock prices. The interest rate decision will impact the macro economic outlook. Inflation concerns remain elevated while employment data shows resilience.",
                "metadata": {
                    "title": "Fed Policy Analysis",
                    "author": "Test Author"
                }
            };

            document.getElementById('result').textContent = 'Sending request...';

            try {
                const res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await res.json();
                document.getElementById('result').textContent = 'Status: ' + res.status + '\n\n' + JSON.stringify(data, null, 2);
            } catch(e) {
                document.getElementById('result').textContent = 'Error: ' + e.message;
            }
        }

        async function testDuplicateIngest() {
            // Use fixed URL to test unique constraint
            const payload = {
                "workspace_id": "00000000-0000-0000-0000-000000000001",
                "source": {
                    "url": "https://example.com/duplicate-test-fixed",
                    "type": "article"
                },
                "content": "This is a test document for unique constraint testing.",
                "metadata": {
                    "title": "Duplicate Test",
                    "author": "Test Author"
                }
            };

            document.getElementById('result').textContent = 'Sending first request...';

            try {
                // First request
                let res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                let data1 = await res.json();

                // Second request with same URL
                document.getElementById('result').textContent = 'Sending second request (duplicate)...';
                res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                let data2 = await res.json();

                document.getElementById('result').textContent =
                    'First Request:\nStatus: ' + res.status + '\n' + JSON.stringify(data1, null, 2) +
                    '\n\nSecond Request (duplicate):\nStatus: ' + res.status + '\n' + JSON.stringify(data2, null, 2);
            } catch(e) {
                document.getElementById('result').textContent = 'Error: ' + e.message;
            }
        }

        async function testQuery() {
            const payload = {
                "workspace_id": "00000000-0000-0000-0000-000000000001",
                "question": "What did the Federal Reserve announce?",
                "mode": "answer",
                "top_k": 5
            };

            document.getElementById('result').textContent = 'Sending query...';

            try {
                const res = await fetch(`${BASE_URL}/query`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await res.json();
                document.getElementById('result').textContent = 'Status: ' + res.status + '\n\n' + JSON.stringify(data, null, 2);
            } catch(e) {
                document.getElementById('result').textContent = 'Error: ' + e.message;
            }
        }

        async function checkChunkVectors() {
            document.getElementById('result').textContent = 'Fetching chunk_vectors...';
            try {
                const res = await fetch(`${BASE_URL}/debug/chunk_vectors`);
                const data = await res.json();
                document.getElementById('result').textContent = 'Status: ' + res.status + '\n\n' + JSON.stringify(data, null, 2);
            } catch(e) {
                document.getElementById('result').textContent = 'Error: ' + e.message;
            }
        }

        async function checkDocuments() {
            document.getElementById('result').textContent = 'Fetching documents...';
            try {
                const res = await fetch(`${BASE_URL}/debug/documents`);
                const data = await res.json();
                document.getElementById('result').textContent = 'Status: ' + res.status + '\n\n' + JSON.stringify(data, null, 2);
            } catch(e) {
                document.getElementById('result').textContent = 'Error: ' + e.message;
            }
        }

        async function checkChunks() {
            document.getElementById('result').textContent = 'Fetching chunks...';
            try {
                const res = await fetch(`${BASE_URL}/debug/chunks`);
                const data = await res.json();
                document.getElementById('result').textContent = 'Status: ' + res.status + '\n\n' + JSON.stringify(data, null, 2);
            } catch(e) {
                document.getElementById('result').textContent = 'Error: ' + e.message;
            }
        }

        async function testYouTubeIngest() {
            // Test with a TED talk video known to have transcripts
            const payload = {
                "workspace_id": "00000000-0000-0000-0000-000000000001",
                "url": "https://www.youtube.com/watch?v=dQw4w9WgXcQ"
            };

            document.getElementById('result').textContent = 'Testing YouTube ingestion...';

            try {
                const res = await fetch(`${BASE_URL}/sources/youtube/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await res.json();
                document.getElementById('result').textContent = 'Status: ' + res.status + '\n\n' + JSON.stringify(data, null, 2);
            } catch(e) {
                document.getElementById('result').textContent = 'Error: ' + e.message;
            }
        }

        async function testReembed() {
            const payload = {
                "workspace_id": "00000000-0000-0000-0000-000000000001",
                "target_collection": "kb_nomic_embed_text_v2",
                "embed_provider": "ollama",
                "embed_model": "nomic-embed-text"
            };

            document.getElementById('result').textContent = 'Testing reembed...';

            try {
                const res = await fetch(`${BASE_URL}/reembed`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await res.json();
                const jobId = data.job_id;

                let output = 'Reembed Response:\nStatus: ' + res.status + '\n' + JSON.stringify(data, null, 2);

                // If job created, poll for status
                if (jobId) {
                    output += '\n\n--- Polling job status ---';
                    for (let i = 0; i < 5; i++) {
                        await new Promise(r => setTimeout(r, 2000));
                        const jobRes = await fetch(`${BASE_URL}/jobs/${jobId}`);
                        const jobData = await jobRes.json();
                        output += `\n\nPoll ${i+1}:\n` + JSON.stringify(jobData, null, 2);
                        if (jobData.status === 'completed' || jobData.status === 'failed') break;
                    }
                }

                document.getElementById('result').textContent = output;
            } catch(e) {
                document.getElementById('result').textContent = 'Error: ' + e.message;
            }
        }

        async function testWorkspaceIsolation() {
            const WORKSPACE_A = "00000000-0000-0000-0000-000000000001";
            let WORKSPACE_B = null;  // Will be set from workspace creation response
            let output = "=== WORKSPACE ISOLATION TEST ===\n\n";

            document.getElementById('result').textContent = 'Step 1: Creating second workspace...';

            try {
                // Step 1: Create second workspace
                let res = await fetch(`${BASE_URL}/debug/workspaces`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: "Test Workspace B",
                        slug: "test-workspace-b"
                    })
                });
                let data = await res.json();
                output += "Step 1 - Create Workspace B:\n" + JSON.stringify(data, null, 2) + "\n\n";

                // Get the actual workspace ID from the response
                if (data.success && data.workspace && data.workspace.id) {
                    WORKSPACE_B = data.workspace.id;
                    output += "Using Workspace B ID: " + WORKSPACE_B + "\n\n";
                } else {
                    output += "ERROR: Could not get workspace B ID\n\n";
                    document.getElementById('result').textContent = output;
                    return;
                }

                // Step 2: Ingest document into Workspace A
                document.getElementById('result').textContent = 'Step 2: Ingesting to Workspace A...';
                const docA = {
                    "workspace_id": WORKSPACE_A,
                    "idempotency_key": "isolation-test-a-" + Date.now(),
                    "source": {
                        "url": "https://example.com/workspace-a-doc-" + Date.now(),
                        "type": "article"
                    },
                    "content": "Workspace A unique content about Bitcoin and cryptocurrency markets. BTC price analysis shows strong momentum.",
                    "metadata": {
                        "title": "Workspace A Document"
                    }
                };
                res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(docA)
                });
                data = await res.json();
                output += "Step 2 - Ingest to Workspace A:\nStatus: " + res.status + "\n" + JSON.stringify(data, null, 2) + "\n\n";

                // Step 3: Ingest document into Workspace B
                document.getElementById('result').textContent = 'Step 3: Ingesting to Workspace B...';
                const docB = {
                    "workspace_id": WORKSPACE_B,
                    "idempotency_key": "isolation-test-b-" + Date.now(),
                    "source": {
                        "url": "https://example.com/workspace-b-doc-" + Date.now(),
                        "type": "article"
                    },
                    "content": "Workspace B unique content about Ethereum and smart contracts. ETH development updates and roadmap.",
                    "metadata": {
                        "title": "Workspace B Document"
                    }
                };
                res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(docB)
                });
                data = await res.json();
                output += "Step 3 - Ingest to Workspace B:\nStatus: " + res.status + "\n" + JSON.stringify(data, null, 2) + "\n\n";

                // Wait for embedding to complete
                await new Promise(r => setTimeout(r, 2000));

                // Step 4: Query Workspace A
                document.getElementById('result').textContent = 'Step 4: Querying Workspace A...';
                res = await fetch(`${BASE_URL}/query`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        "workspace_id": WORKSPACE_A,
                        "question": "Tell me about cryptocurrency",
                        "mode": "retrieve",
                        "top_k": 10
                    })
                });
                data = await res.json();
                output += "Step 4 - Query Workspace A:\nStatus: " + res.status + "\n";
                output += "Results count: " + (data.results ? data.results.length : 0) + "\n";
                if (data.results && data.results.length > 0) {
                    const workspaceIds = data.results.map(r => r.workspace_id || "N/A");
                    output += "Result workspace_ids: " + JSON.stringify(workspaceIds) + "\n";
                    // Check if all results are from Workspace A
                    const allFromA = data.results.every(r => r.workspace_id === WORKSPACE_A);
                    output += "All results from Workspace A: " + allFromA + "\n";
                }
                output += JSON.stringify(data, null, 2) + "\n\n";

                // Step 5: Query Workspace B
                document.getElementById('result').textContent = 'Step 5: Querying Workspace B...';
                res = await fetch(`${BASE_URL}/query`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        "workspace_id": WORKSPACE_B,
                        "question": "Tell me about cryptocurrency",
                        "mode": "retrieve",
                        "top_k": 10
                    })
                });
                data = await res.json();
                output += "Step 5 - Query Workspace B:\nStatus: " + res.status + "\n";
                output += "Results count: " + (data.results ? data.results.length : 0) + "\n";
                if (data.results && data.results.length > 0) {
                    const workspaceIds = data.results.map(r => r.workspace_id || "N/A");
                    output += "Result workspace_ids: " + JSON.stringify(workspaceIds) + "\n";
                    // Check if all results are from Workspace B
                    const allFromB = data.results.every(r => r.workspace_id === WORKSPACE_B);
                    output += "All results from Workspace B: " + allFromB + "\n";
                }
                output += JSON.stringify(data, null, 2) + "\n\n";

                output += "=== TEST COMPLETE ===\n";
                output += "Check that results from Workspace A query contain only Workspace A data,\n";
                output += "and results from Workspace B query contain only Workspace B data.";

                document.getElementById('result').textContent = output;
            } catch(e) {
                document.getElementById('result').textContent = output + '\n\nError: ' + e.message;
            }
        }

        async function testEmptyWorkspaceQuery() {
            let output = "=== EMPTY WORKSPACE QUERY TEST ===\n\n";
            document.getElementById('result').textContent = 'Step 1: Creating empty workspace...';

            try {
                // Step 1: Create a new empty workspace
                const timestamp = Date.now();
                let res = await fetch(`${BASE_URL}/debug/workspaces`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: "Empty Workspace " + timestamp,
                        slug: "empty-workspace-" + timestamp
                    })
                });
                let data = await res.json();
                output += "Step 1 - Create Empty Workspace:\n" + JSON.stringify(data, null, 2) + "\n\n";

                if (!data.success || !data.workspace || !data.workspace.id) {
                    output += "ERROR: Could not create workspace\n";
                    document.getElementById('result').textContent = output;
                    return;
                }

                const emptyWorkspaceId = data.workspace.id;
                output += "Created workspace ID: " + emptyWorkspaceId + "\n\n";

                // Step 2: Query the empty workspace
                document.getElementById('result').textContent = 'Step 2: Querying empty workspace...';
                const startTime = performance.now();
                res = await fetch(`${BASE_URL}/query`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        "workspace_id": emptyWorkspaceId,
                        "question": "What is the meaning of life?",
                        "mode": "retrieve",
                        "top_k": 10
                    })
                });
                const endTime = performance.now();
                const responseTime = endTime - startTime;
                data = await res.json();

                output += "Step 2 - Query Empty Workspace:\n";
                output += "HTTP Status: " + res.status + "\n";
                output += "Response time: " + responseTime.toFixed(2) + "ms\n";
                output += "Results count: " + (data.results ? data.results.length : "N/A") + "\n";
                output += "Response:\n" + JSON.stringify(data, null, 2) + "\n\n";

                // Verify results
                output += "=== VERIFICATION ===\n";
                const isStatus200 = res.status === 200;
                const isResultsEmpty = data.results && data.results.length === 0;
                const isNoError = !data.error && !data.detail;
                const isFast = responseTime < 2000;  // Less than 2 seconds

                output += "Status is 200: " + isStatus200 + "\n";
                output += "Results array is empty: " + isResultsEmpty + "\n";
                output += "No error raised: " + isNoError + "\n";
                output += "Response time < 2s: " + isFast + " (" + responseTime.toFixed(2) + "ms)\n";
                output += "\n=== TEST " + (isStatus200 && isResultsEmpty && isNoError && isFast ? "PASSED" : "FAILED") + " ===\n";

                document.getElementById('result').textContent = output;
            } catch(e) {
                document.getElementById('result').textContent = output + '\n\nError: ' + e.message;
            }
        }

        async function testReembedEmptyWorkspace() {
            let output = "=== REEMBED EMPTY WORKSPACE TEST ===\n\n";
            document.getElementById('result').textContent = 'Step 1: Creating empty workspace...';

            try {
                // Step 1: Create a new empty workspace
                const timestamp = Date.now();
                let res = await fetch(`${BASE_URL}/debug/workspaces`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: "Reembed Test Workspace " + timestamp,
                        slug: "reembed-test-" + timestamp
                    })
                });
                let data = await res.json();
                output += "Step 1 - Create Empty Workspace:\n" + JSON.stringify(data, null, 2) + "\n\n";

                if (!data.success || !data.workspace || !data.workspace.id) {
                    output += "ERROR: Could not create workspace\n";
                    document.getElementById('result').textContent = output;
                    return;
                }

                const emptyWorkspaceId = data.workspace.id;
                output += "Created workspace ID: " + emptyWorkspaceId + "\n\n";

                // Step 2: POST /reembed for this empty workspace
                document.getElementById('result').textContent = 'Step 2: Requesting reembed for empty workspace...';
                res = await fetch(`${BASE_URL}/reembed`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        "workspace_id": emptyWorkspaceId,
                        "target_collection": "kb_nomic_embed_text_v2",
                        "embed_provider": "ollama",
                        "embed_model": "nomic-embed-text"
                    })
                });
                data = await res.json();
                output += "Step 2 - Reembed Request:\n";
                output += "HTTP Status: " + res.status + "\n";
                output += "Response:\n" + JSON.stringify(data, null, 2) + "\n\n";

                const jobId = data.job_id;
                if (!jobId) {
                    output += "=== VERIFICATION ===\n";
                    output += "No job_id returned - checking if this is handled gracefully\n";
                    const isGraceful = res.status === 200 || res.status === 201;
                    output += "Request completed gracefully: " + isGraceful + "\n";
                    output += "\n=== TEST " + (isGraceful ? "PASSED" : "FAILED") + " ===\n";
                    document.getElementById('result').textContent = output;
                    return;
                }

                // Step 3: Poll job status
                document.getElementById('result').textContent = 'Step 3: Polling job status...';
                let jobStatus = null;
                for (let i = 0; i < 10; i++) {
                    await new Promise(r => setTimeout(r, 1000));
                    res = await fetch(`${BASE_URL}/jobs/${jobId}`);
                    data = await res.json();
                    output += "Poll " + (i+1) + ":\n" + JSON.stringify(data, null, 2) + "\n";

                    if (data.status === 'completed' || data.status === 'failed') {
                        jobStatus = data;
                        break;
                    }
                }

                output += "\n=== VERIFICATION ===\n";
                const isCompleted = jobStatus && jobStatus.status === 'completed';
                const hasZeroChunks = jobStatus && (jobStatus.chunks_queued === 0 || jobStatus.progress === 0);
                output += "Job completed successfully: " + isCompleted + "\n";
                output += "Chunks queued is 0 or progress is 0: " + hasZeroChunks + "\n";
                output += "\n=== TEST " + (isCompleted ? "PASSED" : "FAILED") + " ===\n";

                document.getElementById('result').textContent = output;
            } catch(e) {
                document.getElementById('result').textContent = output + '\n\nError: ' + e.message;
            }
        }

        async function testLargeContent() {
            let output = "=== LARGE CONTENT INGESTION TEST (10000+ tokens) ===\n\n";
            document.getElementById('result').textContent = 'Generating large content (10000+ tokens)...';

            try {
                // Generate content with 10000+ tokens (approximately 40000+ characters)
                // Each paragraph is about 100 words (~133 tokens)
                const baseParagraphs = [
                    "The Federal Reserve announced significant changes to monetary policy affecting global markets. Chairman Powell emphasized the importance of maintaining price stability while supporting maximum employment. Interest rate decisions will be data-dependent, with careful monitoring of inflation indicators and labor market conditions. The committee remains vigilant about upside risks to inflation and is prepared to adjust policy stance as appropriate. Financial conditions have tightened considerably over the past year, and the full effects of policy tightening are yet to be felt.",
                    "Apple Inc (AAPL) reported strong quarterly earnings, beating analyst expectations on both revenue and earnings per share. The company's services segment showed remarkable growth, contributing significantly to overall revenue. iPhone sales remained robust despite challenging macroeconomic conditions. Management provided optimistic guidance for the upcoming quarter, citing strong demand for premium devices. The stock rallied following the earnings announcement, reaching new all-time highs.",
                    "Microsoft Corporation (MSFT) continues to dominate the cloud computing market with Azure showing impressive growth rates. The company's artificial intelligence initiatives are gaining traction across enterprise customers. Office 365 subscription revenue grew steadily, demonstrating strong recurring revenue streams. Gaming division performed well with Xbox Game Pass subscriber growth accelerating. Management highlighted significant investments in AI infrastructure and partnerships.",
                    "Google (GOOGL) faces increased regulatory scrutiny as antitrust investigations continue globally. Search advertising revenue showed resilience despite competitive pressures from social media platforms. YouTube's advertising business demonstrated strong performance with increased watch time. Cloud Platform growth remained robust, though still trailing competitors in market share. The company announced ambitious AI product roadmaps across consumer and enterprise segments.",
                    "Amazon (AMZN) navigates challenging retail environment while AWS continues to drive profitability. E-commerce growth normalized after pandemic-driven surge, leading to operational efficiency measures. Third-party seller services showed healthy growth, contributing to marketplace ecosystem strength. Prime membership retention remained strong with expanded benefits and content offerings. Management emphasizes long-term investments in logistics and fulfillment capabilities.",
                    "Tesla (TSLA) expands production capacity with new gigafactories coming online globally. Electric vehicle demand remains strong despite increasing competition from traditional automakers. Energy storage and solar businesses show promising growth trajectories. Full self-driving technology continues to progress through beta testing phases. The company maintains cost leadership through vertical integration and manufacturing innovations.",
                    "NVIDIA (NVDA) dominates AI chip market with unprecedented demand for data center GPUs. Gaming segment performs well with new graphics card generations driving upgrade cycles. Automotive business shows steady growth with autonomous driving partnerships expanding. Data center revenue exceeds expectations as AI training workloads surge. Management projects continued strong demand from cloud service providers and enterprises.",
                    "Meta Platforms (META) focuses on metaverse investments while maintaining advertising revenue strength. Instagram Reels shows strong engagement competing effectively with TikTok platform. Reality Labs division continues significant investments despite ongoing losses. AI-driven content recommendations improve user engagement metrics across platforms. Advertising efficiency tools help small businesses optimize marketing spend.",
                    "Netflix (NFLX) adapts to streaming market maturation with ad-supported tier launch. Content investment strategy shifts toward quality over quantity approach. Password sharing crackdown shows initial positive impact on subscriber growth. International expansion continues with localized content production increasing. The company explores gaming and live events as growth vectors.",
                    "JPMorgan Chase (JPM) benefits from rising interest rate environment boosting net interest income. Investment banking activity remains subdued amid market volatility and uncertainty. Consumer banking shows resilience with strong deposit growth and loan demand. Credit quality metrics remain healthy despite economic headwinds concerns. Management maintains cautious outlook on commercial real estate exposure."
                ];

                // Repeat paragraphs to get to 10000+ tokens (need about 75+ paragraphs)
                let largeContent = "";
                for (let i = 0; i < 80; i++) {
                    const paragraph = baseParagraphs[i % baseParagraphs.length];
                    // Add variation to prevent exact duplicates
                    largeContent += `[Section ${i + 1}] ${paragraph} Market conditions as of iteration ${i + 1} show continued volatility.\n\n`;
                }

                const estimatedTokens = Math.ceil(largeContent.length / 4);  // Rough estimate: 4 chars per token
                output += `Generated content length: ${largeContent.length} characters\n`;
                output += `Estimated tokens: ~${estimatedTokens}\n\n`;

                const payload = {
                    "workspace_id": "00000000-0000-0000-0000-000000000001",
                    "idempotency_key": "large-content-test-" + Date.now(),
                    "source": {
                        "url": "https://example.com/large-document-" + Date.now(),
                        "type": "article"
                    },
                    "content": largeContent,
                    "metadata": {
                        "title": "Large Content Test Document",
                        "author": "Test Author"
                    }
                };

                document.getElementById('result').textContent = 'Sending large content request...';
                output += "Sending request to /ingest...\n";

                const startTime = performance.now();
                const res = await fetch(`${BASE_URL}/ingest`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const endTime = performance.now();
                const duration = (endTime - startTime) / 1000;  // Convert to seconds

                const data = await res.json();

                output += `\nResponse received!\n`;
                output += `HTTP Status: ${res.status}\n`;
                output += `Duration: ${duration.toFixed(2)} seconds\n`;
                output += `Response:\n${JSON.stringify(data, null, 2)}\n\n`;

                // Verification
                output += "=== VERIFICATION ===\n";
                const isSuccess = res.status === 200 || res.status === 201;
                const hasDocId = !!data.doc_id;
                const hasChunks = data.chunks_created > 0;
                const isWithinTime = duration < 60;  // Should complete within 60 seconds
                const hasMultipleChunks = data.chunks_created >= 10;  // Large content should create many chunks

                output += `Request successful (200/201): ${isSuccess}\n`;
                output += `Has doc_id: ${hasDocId}\n`;
                output += `Created chunks: ${data.chunks_created}\n`;
                output += `Has multiple chunks (>=10): ${hasMultipleChunks}\n`;
                output += `Created vectors: ${data.vectors_created}\n`;
                output += `Completed within 60s: ${isWithinTime} (${duration.toFixed(2)}s)\n`;

                const testPassed = isSuccess && hasDocId && hasMultipleChunks && isWithinTime;
                output += `\n=== TEST ${testPassed ? "PASSED" : "FAILED"} ===\n`;

                document.getElementById('result').textContent = output;
            } catch(e) {
                document.getElementById('result').textContent = output + '\n\nError: ' + e.message;
            }
        }

        async function testConcurrentRequests() {
            let output = "=== CONCURRENT REQUESTS TEST ===\n\n";
            document.getElementById('result').textContent = 'Preparing 10 concurrent requests...';

            try {
                const CONCURRENT_COUNT = 10;
                const requests = [];

                // Prepare 10 different payloads
                for (let i = 0; i < CONCURRENT_COUNT; i++) {
                    const timestamp = Date.now();
                    requests.push({
                        "workspace_id": "00000000-0000-0000-0000-000000000001",
                        "idempotency_key": `concurrent-test-${timestamp}-${i}`,
                        "source": {
                            "url": `https://example.com/concurrent-${timestamp}-${i}`,
                            "type": "article"
                        },
                        "content": `Concurrent test document ${i + 1}. This tests the service's ability to handle multiple simultaneous ingestion requests. Each document contains unique content about request number ${i + 1} with different metadata to ensure proper isolation. Stock symbols mentioned: AAPL, MSFT, GOOGL.`,
                        "metadata": {
                            "title": `Concurrent Test ${i + 1}`,
                            "author": `Author ${i + 1}`
                        }
                    });
                }

                output += `Prepared ${CONCURRENT_COUNT} requests\n\n`;
                document.getElementById('result').textContent = 'Sending 10 concurrent requests...';

                const startTime = performance.now();

                // Send all requests concurrently
                const promises = requests.map((payload, index) =>
                    fetch(`${BASE_URL}/ingest`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    }).then(async res => {
                        const data = await res.json();
                        return { index, status: res.status, data };
                    }).catch(err => {
                        return { index, status: 'error', error: err.message };
                    })
                );

                const results = await Promise.all(promises);
                const endTime = performance.now();
                const totalDuration = (endTime - startTime) / 1000;

                output += "=== RESULTS ===\n\n";

                let successCount = 0;
                let errorCount = 0;
                const docIds = new Set();

                results.forEach(result => {
                    output += `Request ${result.index + 1}: `;
                    if (result.status === 200 || result.status === 201) {
                        successCount++;
                        if (result.data.doc_id) {
                            docIds.add(result.data.doc_id);
                        }
                        output += `Status ${result.status}, doc_id: ${result.data.doc_id}, chunks: ${result.data.chunks_created}\n`;
                    } else if (result.status === 'error') {
                        errorCount++;
                        output += `ERROR: ${result.error}\n`;
                    } else {
                        errorCount++;
                        output += `Status ${result.status}: ${JSON.stringify(result.data)}\n`;
                    }
                });

                output += `\nTotal duration: ${totalDuration.toFixed(2)} seconds\n`;
                output += `Average per request: ${(totalDuration / CONCURRENT_COUNT).toFixed(2)} seconds\n\n`;

                // Verification
                output += "=== VERIFICATION ===\n";
                const allSucceeded = successCount === CONCURRENT_COUNT;
                const noErrors = errorCount === 0;
                const uniqueDocIds = docIds.size === CONCURRENT_COUNT;
                const reasonableTime = totalDuration < 60;

                output += `All requests succeeded: ${allSucceeded} (${successCount}/${CONCURRENT_COUNT})\n`;
                output += `No errors: ${noErrors}\n`;
                output += `Unique doc_ids: ${uniqueDocIds} (${docIds.size}/${CONCURRENT_COUNT})\n`;
                output += `Completed within 60s: ${reasonableTime} (${totalDuration.toFixed(2)}s)\n`;

                const testPassed = allSucceeded && noErrors && uniqueDocIds && reasonableTime;
                output += `\n=== TEST ${testPassed ? "PASSED" : "FAILED"} ===\n`;

                document.getElementById('result').textContent = output;
            } catch(e) {
                document.getElementById('result').textContent = output + '\n\nError: ' + e.message;
            }
        }
    </script>
</body>
</html>
