[
  {
    "category": "functional",
    "description": "Health endpoint returns 200 OK with all required fields",
    "steps": [
      "Step 1: Start the FastAPI service",
      "Step 2: Send GET request to /health",
      "Step 3: Verify response status is 200",
      "Step 4: Verify response contains 'status' field",
      "Step 5: Verify response contains 'qdrant' field with status",
      "Step 6: Verify response contains 'supabase' field with status",
      "Step 7: Verify response contains 'ollama' field with status",
      "Step 8: Verify response contains 'active_collection' field",
      "Step 9: Verify response contains 'embed_model' field",
      "Step 10: Verify response contains 'latency_ms' object with per-dependency timings",
      "Step 11: Verify response contains 'version' field"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Health endpoint correctly reports Qdrant connectivity status",
    "steps": [
      "Step 1: Start the service with Qdrant running",
      "Step 2: GET /health and verify qdrant status is 'ok'",
      "Step 3: Stop Qdrant container",
      "Step 4: GET /health and verify qdrant status is 'error'",
      "Step 5: Restart Qdrant container",
      "Step 6: GET /health and verify qdrant status returns to 'ok'"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Health endpoint correctly reports Supabase connectivity status",
    "steps": [
      "Step 1: Start the service with valid Supabase credentials",
      "Step 2: GET /health and verify supabase status is 'ok'",
      "Step 3: Temporarily invalidate Supabase credentials",
      "Step 4: GET /health and verify supabase status is 'error'",
      "Step 5: Restore valid credentials and verify status returns to 'ok'"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Health endpoint correctly reports Ollama connectivity status",
    "steps": [
      "Step 1: Start the service with Ollama running",
      "Step 2: GET /health and verify ollama status is 'ok'",
      "Step 3: Stop Ollama container",
      "Step 4: GET /health and verify ollama status is 'error'"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Health endpoint latency_ms values are reasonable (<500ms)",
    "steps": [
      "Step 1: Start all services",
      "Step 2: GET /health",
      "Step 3: Verify latency_ms.qdrant < 500",
      "Step 4: Verify latency_ms.supabase < 500",
      "Step 5: Verify latency_ms.ollama < 500"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "POST /ingest creates a new document successfully",
    "steps": [
      "Step 1: Prepare valid ingest payload with workspace_id, source, content, metadata",
      "Step 2: POST to /ingest",
      "Step 3: Verify response status is 200 or 201",
      "Step 4: Verify response contains doc_id (UUID)",
      "Step 5: Verify response contains chunks_created > 0",
      "Step 6: Verify response contains vectors_created > 0",
      "Step 7: Verify response status is 'created' or 'indexed'"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /ingest with idempotency_key prevents duplicate documents",
    "steps": [
      "Step 1: Create ingest payload with unique idempotency_key",
      "Step 2: POST to /ingest",
      "Step 3: Verify document is created successfully",
      "Step 4: POST same payload with same idempotency_key again",
      "Step 5: Verify response indicates existing document (status: 'exists' or returns same doc_id)",
      "Step 6: Verify no duplicate chunks were created in database"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /ingest deduplicates based on content_hash",
    "steps": [
      "Step 1: Create payload with specific content",
      "Step 2: POST to /ingest",
      "Step 3: Note the doc_id returned",
      "Step 4: Create new payload with identical content but no idempotency_key",
      "Step 5: POST to /ingest",
      "Step 6: Verify system detects duplicate via content_hash"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /ingest handles pre-chunked content correctly",
    "steps": [
      "Step 1: Create payload with pre-defined chunks array",
      "Step 2: POST to /ingest",
      "Step 3: Verify chunks_created matches number of provided chunks",
      "Step 4: Query database to verify chunk order is preserved",
      "Step 5: Verify no automatic chunking was performed on pre-chunked content"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /ingest validates required fields",
    "steps": [
      "Step 1: POST payload missing workspace_id",
      "Step 2: Verify 422 validation error",
      "Step 3: POST payload missing source",
      "Step 4: Verify 422 validation error",
      "Step 5: POST payload missing content",
      "Step 6: Verify 422 validation error"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Chunking splits content into ~512 token chunks",
    "steps": [
      "Step 1: POST /ingest with content of 2000+ tokens",
      "Step 2: Verify multiple chunks created",
      "Step 3: Query database for chunk token_count values",
      "Step 4: Verify each chunk's token_count is <= 512 (with reasonable tolerance)",
      "Step 5: Verify chunks don't have excessive overlap"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Chunking preserves content integrity (no lost text)",
    "steps": [
      "Step 1: POST /ingest with specific known content",
      "Step 2: Query database for all chunks of the document",
      "Step 3: Concatenate chunk contents",
      "Step 4: Verify all original content is present in concatenated result"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metadata extraction identifies stock symbols correctly",
    "steps": [
      "Step 1: POST /ingest with content containing 'AAPL, GOOGL, MSFT mentioned in analysis'",
      "Step 2: Query chunks from database",
      "Step 3: Verify symbols array contains ['AAPL', 'GOOGL', 'MSFT']",
      "Step 4: Verify symbols are uppercase normalized"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metadata extraction identifies entities (Fed, Powell, FOMC)",
    "steps": [
      "Step 1: POST /ingest with content mentioning 'Fed', 'Powell', 'FOMC'",
      "Step 2: Query chunks from database",
      "Step 3: Verify entities array contains extracted entities",
      "Step 4: Verify entity extraction is case-insensitive"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metadata extraction identifies topics correctly",
    "steps": [
      "Step 1: POST /ingest with content about interest rates and macro economics",
      "Step 2: Query chunks from database",
      "Step 3: Verify topics array contains relevant topics like 'rates', 'macro'"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Embeddings are generated with correct dimensions (768 for nomic-embed-text)",
    "steps": [
      "Step 1: POST /ingest with sample content",
      "Step 2: Query Qdrant for the created vectors",
      "Step 3: Verify vector dimension is 768",
      "Step 4: Verify vectors are non-zero"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Embeddings are stored in Qdrant with correct payload structure",
    "steps": [
      "Step 1: POST /ingest with content including symbols, topics",
      "Step 2: Query Qdrant for the created points",
      "Step 3: Verify payload contains workspace_id",
      "Step 4: Verify payload contains doc_id",
      "Step 5: Verify payload contains source_type",
      "Step 6: Verify payload contains symbols array",
      "Step 7: Verify payload contains topics array"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "chunk_vectors table tracks embedding records correctly",
    "steps": [
      "Step 1: POST /ingest with sample content",
      "Step 2: Query chunk_vectors table in Supabase",
      "Step 3: Verify records exist for each chunk",
      "Step 4: Verify embed_provider is 'ollama'",
      "Step 5: Verify embed_model is 'nomic-embed-text'",
      "Step 6: Verify collection name follows pattern kb_{model}_{version}",
      "Step 7: Verify vector_dim is 768",
      "Step 8: Verify status is 'indexed'"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /sources/youtube/ingest processes single video URL",
    "steps": [
      "Step 1: Prepare payload with valid YouTube video URL",
      "Step 2: POST to /sources/youtube/ingest",
      "Step 3: Verify response status is 200",
      "Step 4: Verify response contains doc_id",
      "Step 5: Verify response contains video_id",
      "Step 6: Verify is_playlist is false",
      "Step 7: Verify chunks_created > 0"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /sources/youtube/ingest extracts video metadata correctly",
    "steps": [
      "Step 1: POST /sources/youtube/ingest with known video URL",
      "Step 2: Query documents table for the created record",
      "Step 3: Verify title is extracted",
      "Step 4: Verify channel is extracted",
      "Step 5: Verify published_at is extracted",
      "Step 6: Verify duration_secs is extracted",
      "Step 7: Verify video_id matches URL"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /sources/youtube/ingest handles playlist URLs",
    "steps": [
      "Step 1: Prepare payload with YouTube playlist URL",
      "Step 2: POST to /sources/youtube/ingest",
      "Step 3: Verify is_playlist is true",
      "Step 4: Verify video_urls array is returned",
      "Step 5: Verify video_urls contains individual video URLs"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "YouTube transcript chunks include timestamp information",
    "steps": [
      "Step 1: POST /sources/youtube/ingest with video URL",
      "Step 2: Query chunks table for created chunks",
      "Step 3: Verify time_start_secs is populated",
      "Step 4: Verify time_end_secs is populated",
      "Step 5: Verify locator_label contains timestamp format (e.g., '12:34')"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "YouTube transcript normalizer removes artifacts like [Music]",
    "steps": [
      "Step 1: Ingest a video known to have [Music] markers in transcript",
      "Step 2: Query chunks content",
      "Step 3: Verify [Music] markers are removed or normalized",
      "Step 4: Verify repeated phrases are collapsed"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "YouTube ingestion handles missing transcript gracefully",
    "steps": [
      "Step 1: POST /sources/youtube/ingest with video URL that has no transcript",
      "Step 2: Verify response status indicates error",
      "Step 3: Verify status is terminal (retryable: false)",
      "Step 4: Verify error_reason indicates no_transcript"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "YouTube ingestion uses retry with exponential backoff",
    "steps": [
      "Step 1: Configure mock to fail first 2 transcript fetches",
      "Step 2: POST /sources/youtube/ingest",
      "Step 3: Verify service retries with increasing delays",
      "Step 4: Verify eventual success on third attempt"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "POST /query performs semantic search and returns results",
    "steps": [
      "Step 1: Ingest sample documents about specific topics",
      "Step 2: POST /query with related question",
      "Step 3: Verify response contains results array",
      "Step 4: Verify results are semantically relevant to query",
      "Step 5: Verify each result contains chunk content"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /query respects retrieve_k and top_k parameters",
    "steps": [
      "Step 1: Ingest 20+ documents",
      "Step 2: POST /query with retrieve_k=15, top_k=5",
      "Step 3: Verify exactly 5 results returned",
      "Step 4: POST /query with retrieve_k=10, top_k=10",
      "Step 5: Verify 10 results returned"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /query filters by source_types correctly",
    "steps": [
      "Step 1: Ingest documents with source_type='youtube'",
      "Step 2: Ingest documents with source_type='pdf'",
      "Step 3: POST /query with filters.source_types=['youtube']",
      "Step 4: Verify all results have source_type='youtube'",
      "Step 5: Verify no pdf results included"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /query filters by symbols with 'any' mode",
    "steps": [
      "Step 1: Ingest documents mentioning AAPL, GOOGL, MSFT separately",
      "Step 2: POST /query with filters.symbols=['AAPL', 'GOOGL'], symbols_mode='any'",
      "Step 3: Verify results include documents mentioning AAPL OR GOOGL",
      "Step 4: Verify results don't exclude documents with only one symbol"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /query filters by symbols with 'all' mode",
    "steps": [
      "Step 1: Ingest document mentioning both AAPL and GOOGL",
      "Step 2: Ingest document mentioning only AAPL",
      "Step 3: POST /query with filters.symbols=['AAPL', 'GOOGL'], symbols_mode='all'",
      "Step 4: Verify only documents with BOTH symbols are returned"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /query filters by date range (published_from, published_to)",
    "steps": [
      "Step 1: Ingest documents with various published_at dates",
      "Step 2: POST /query with published_from='2024-01-01'",
      "Step 3: Verify all results have published_at >= 2024-01-01",
      "Step 4: POST /query with published_to='2024-06-30'",
      "Step 5: Verify all results have published_at <= 2024-06-30"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /query filters by topics correctly",
    "steps": [
      "Step 1: Ingest documents about macro, earnings, tech topics",
      "Step 2: POST /query with filters.topics=['macro']",
      "Step 3: Verify results are filtered to macro topic documents"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /query filters by entities correctly",
    "steps": [
      "Step 1: Ingest documents mentioning Fed, Powell, various companies",
      "Step 2: POST /query with filters.entities=['Powell']",
      "Step 3: Verify results mention Powell"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /query filters by authors correctly",
    "steps": [
      "Step 1: Ingest documents from different authors/channels",
      "Step 2: POST /query with filters.authors=['SpecificChannel']",
      "Step 3: Verify results are from specified author/channel"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /query mode='retrieve' returns only chunks without answer",
    "steps": [
      "Step 1: POST /query with mode='retrieve'",
      "Step 2: Verify response contains results array",
      "Step 3: Verify response does not contain 'answer' field or answer is null"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /query mode='answer' returns LLM-generated answer",
    "steps": [
      "Step 1: Ingest relevant documents",
      "Step 2: POST /query with mode='answer'",
      "Step 3: Verify response contains 'answer' field",
      "Step 4: Verify answer is non-empty string",
      "Step 5: Verify answer includes citations like [1], [2]"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /query answer includes source attribution with URLs",
    "steps": [
      "Step 1: Ingest YouTube video",
      "Step 2: POST /query with mode='answer'",
      "Step 3: Verify results contain citation URLs",
      "Step 4: Verify YouTube URLs include timestamp parameter (t=123)"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /query preserves ranking order from Qdrant in hydrated results",
    "steps": [
      "Step 1: Ingest multiple documents",
      "Step 2: POST /query",
      "Step 3: Verify results are ordered by relevance score descending",
      "Step 4: Verify Postgres hydration doesn't change the order"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Query hydration fetches full chunk content from Postgres",
    "steps": [
      "Step 1: Ingest document with substantial content",
      "Step 2: POST /query",
      "Step 3: Verify each result contains full chunk content",
      "Step 4: Verify content matches what was stored in chunks table"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /reembed starts async re-embedding job",
    "steps": [
      "Step 1: Ingest several documents",
      "Step 2: POST /reembed with target_collection and embed config",
      "Step 3: Verify response contains job_id",
      "Step 4: Verify response status is 'started'",
      "Step 5: Verify chunks_queued matches expected count"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /reembed filters by workspace_id",
    "steps": [
      "Step 1: Ingest documents in workspace A",
      "Step 2: Ingest documents in workspace B",
      "Step 3: POST /reembed for workspace A only",
      "Step 4: Verify only workspace A chunks are queued",
      "Step 5: Verify workspace B chunks are not affected"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "POST /reembed filters by doc_ids when provided",
    "steps": [
      "Step 1: Ingest 3 documents",
      "Step 2: POST /reembed with doc_ids=[doc1, doc2]",
      "Step 3: Verify only chunks from doc1 and doc2 are re-embedded",
      "Step 4: Verify doc3 chunks are not affected"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "GET /jobs/{job_id} returns job status correctly",
    "steps": [
      "Step 1: POST /reembed to create a job",
      "Step 2: GET /jobs/{job_id} with returned job_id",
      "Step 3: Verify response contains job_id",
      "Step 4: Verify response contains status (started/running/completed/failed)",
      "Step 5: Verify response contains progress percentage"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "GET /jobs/{job_id} shows job completion",
    "steps": [
      "Step 1: POST /reembed with small dataset",
      "Step 2: Poll GET /jobs/{job_id} until status changes",
      "Step 3: Verify final status is 'completed'",
      "Step 4: Verify progress is 100%"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "GET /jobs/{job_id} returns 404 for unknown job_id",
    "steps": [
      "Step 1: GET /jobs/non-existent-uuid",
      "Step 2: Verify response status is 404"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Collection naming follows kb_{model}_{version} pattern",
    "steps": [
      "Step 1: Check active collection name via /health",
      "Step 2: Verify name matches pattern kb_nomic_embed_text_v1 (or similar)",
      "Step 3: POST /reembed with new model/version",
      "Step 4: Verify new collection created with correct naming"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Database documents table stores all required fields",
    "steps": [
      "Step 1: POST /ingest with full metadata",
      "Step 2: Query documents table directly",
      "Step 3: Verify id is UUID",
      "Step 4: Verify workspace_id is stored",
      "Step 5: Verify source_url is stored",
      "Step 6: Verify canonical_url is stored",
      "Step 7: Verify source_type is stored",
      "Step 8: Verify content_hash is stored",
      "Step 9: Verify title is stored",
      "Step 10: Verify created_at and updated_at are set"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Database chunks table stores all required fields",
    "steps": [
      "Step 1: POST /ingest",
      "Step 2: Query chunks table directly",
      "Step 3: Verify id is UUID",
      "Step 4: Verify doc_id references documents table",
      "Step 5: Verify chunk_index is sequential",
      "Step 6: Verify content is stored",
      "Step 7: Verify token_count is stored",
      "Step 8: Verify symbols, entities, topics arrays are stored"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Database unique constraint on (workspace_id, source_type, canonical_url)",
    "steps": [
      "Step 1: POST /ingest with specific workspace, source_type, canonical_url",
      "Step 2: Attempt POST /ingest with same values",
      "Step 3: Verify constraint prevents duplicate or returns existing doc"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Database updated_at trigger updates timestamp on row modification",
    "steps": [
      "Step 1: Insert document and note updated_at",
      "Step 2: Wait 1 second",
      "Step 3: Update document",
      "Step 4: Verify updated_at has changed"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Qdrant payload indexes exist and are functional",
    "steps": [
      "Step 1: Query Qdrant collection info",
      "Step 2: Verify workspace_id index exists",
      "Step 3: Verify published_at index exists",
      "Step 4: Verify source_type index exists",
      "Step 5: Verify symbols index exists",
      "Step 6: Verify topics index exists"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Request ID middleware adds request_id to all requests",
    "steps": [
      "Step 1: Send request without X-Request-ID header",
      "Step 2: Verify response includes X-Request-ID header",
      "Step 3: Verify logs include the request_id",
      "Step 4: Send request with custom X-Request-ID header",
      "Step 5: Verify that provided ID is used in response"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Structured logging includes request context",
    "steps": [
      "Step 1: Send request to any endpoint",
      "Step 2: Check service logs",
      "Step 3: Verify logs are JSON formatted",
      "Step 4: Verify logs include request_id",
      "Step 5: Verify logs include timestamp",
      "Step 6: Verify logs include level"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Error responses include retryable flag",
    "steps": [
      "Step 1: Cause a retryable error (e.g., rate limit)",
      "Step 2: Verify response includes retryable: true",
      "Step 3: Cause a terminal error (e.g., no transcript)",
      "Step 4: Verify response includes retryable: false"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Service handles concurrent requests without race conditions",
    "steps": [
      "Step 1: Send 10 concurrent /ingest requests",
      "Step 2: Verify all requests complete without errors",
      "Step 3: Verify no duplicate documents created",
      "Step 4: Verify database state is consistent"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Service handles large content (10000+ tokens) without timeout",
    "steps": [
      "Step 1: Prepare content with 10000+ tokens",
      "Step 2: POST /ingest with large content",
      "Step 3: Verify request completes within reasonable time (<60s)",
      "Step 4: Verify all chunks created correctly"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Batch embedding processes multiple chunks efficiently",
    "steps": [
      "Step 1: Ingest document that creates 20+ chunks",
      "Step 2: Measure time for embedding completion",
      "Step 3: Verify batch processing (not sequential per-chunk calls)",
      "Step 4: Verify all embeddings created successfully"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Write-new-first pattern prevents data loss on update failure",
    "steps": [
      "Step 1: Ingest document version 1",
      "Step 2: Start update to version 2",
      "Step 3: Simulate failure during update",
      "Step 4: Verify version 1 chunks still exist",
      "Step 5: Verify no partial version 2 data present"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Document supersede flow marks old version correctly",
    "steps": [
      "Step 1: Ingest document with canonical_url X",
      "Step 2: Update document at canonical_url X with new content",
      "Step 3: Verify old document status is 'superseded'",
      "Step 4: Verify new document status is 'active'",
      "Step 5: Verify old chunks removed from Qdrant"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "PDF source type stores page numbers correctly",
    "steps": [
      "Step 1: POST /ingest with source_type='pdf' and page info",
      "Step 2: Query chunks table",
      "Step 3: Verify page_start is stored",
      "Step 4: Verify page_end is stored",
      "Step 5: Verify locator_label contains 'p. X' format"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Citation URL builder creates YouTube links with timestamps",
    "steps": [
      "Step 1: Ingest YouTube video",
      "Step 2: POST /query for that video's content",
      "Step 3: Verify citation URL format is youtube.com/watch?v=XXX&t=YYY",
      "Step 4: Verify timestamp parameter matches chunk's time_start_secs"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Citation URL builder creates generic URLs for non-YouTube content",
    "steps": [
      "Step 1: Ingest article with source_url",
      "Step 2: POST /query for that article's content",
      "Step 3: Verify citation URL matches source_url"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Environment configuration loads from .env file",
    "steps": [
      "Step 1: Set SUPABASE_URL in .env",
      "Step 2: Start service",
      "Step 3: Verify service connects to specified Supabase URL"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Service validates embedding dimension at startup",
    "steps": [
      "Step 1: Create Qdrant collection with mismatched dimensions",
      "Step 2: Start service",
      "Step 3: Verify service logs warning about dimension mismatch",
      "Step 4: Verify service either fails fast or creates correct collection"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "OpenRouter API integration for answer generation",
    "steps": [
      "Step 1: Configure OPENROUTER_API_KEY",
      "Step 2: POST /query with mode='answer'",
      "Step 3: Verify LLM is called via OpenRouter",
      "Step 4: Verify response model matches configured answer_model"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Answer generation respects max_context_tokens",
    "steps": [
      "Step 1: Ingest large corpus",
      "Step 2: POST /query with max_context_tokens=2000",
      "Step 3: Verify context passed to LLM doesn't exceed 2000 tokens",
      "Step 4: Verify truncation happens cleanly (not mid-chunk)"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Reranking improves result relevance",
    "steps": [
      "Step 1: Ingest documents with varying relevance",
      "Step 2: POST /query without reranking",
      "Step 3: Note result order",
      "Step 4: POST /query with rerank=true",
      "Step 5: Verify result order may differ (reranked)"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Symbol extraction handles common ticker formats",
    "steps": [
      "Step 1: Ingest content with $AAPL, AAPL, aapl variations",
      "Step 2: Query chunks",
      "Step 3: Verify all normalized to uppercase AAPL"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Symbol extraction uses allowlist to avoid false positives",
    "steps": [
      "Step 1: Ingest content with common words that look like tickers (e.g., 'IT', 'A')",
      "Step 2: Query chunks",
      "Step 3: Verify common false positives are filtered out"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Entity extraction identifies company names",
    "steps": [
      "Step 1: Ingest content mentioning 'Apple Inc.', 'Microsoft Corporation'",
      "Step 2: Query chunks",
      "Step 3: Verify entities array contains company names"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Topic classification for earnings content",
    "steps": [
      "Step 1: Ingest content about 'Q3 earnings', 'EPS beat', 'revenue growth'",
      "Step 2: Query chunks",
      "Step 3: Verify topics contains 'earnings'"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Topic classification for macro content",
    "steps": [
      "Step 1: Ingest content about 'inflation', 'GDP', 'employment'",
      "Step 2: Query chunks",
      "Step 3: Verify topics contains 'macro'"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Speaker detection for multi-speaker content",
    "steps": [
      "Step 1: Ingest podcast/interview transcript with speaker labels",
      "Step 2: Query chunks",
      "Step 3: Verify speaker field is populated where detected"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Quality score estimation for transcripts",
    "steps": [
      "Step 1: Ingest transcript with high-quality text",
      "Step 2: Query chunks and note quality_score",
      "Step 3: Ingest transcript with low-quality/noisy text",
      "Step 4: Verify quality_score reflects confidence difference"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Pydantic validation rejects invalid source_type",
    "steps": [
      "Step 1: POST /ingest with source_type='invalid_type'",
      "Step 2: Verify 422 validation error with helpful message"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Pydantic validation rejects malformed UUIDs",
    "steps": [
      "Step 1: POST /ingest with workspace_id='not-a-uuid'",
      "Step 2: Verify 422 validation error"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "API handles empty content gracefully",
    "steps": [
      "Step 1: POST /ingest with content=''",
      "Step 2: Verify appropriate error response (400 or 422)"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "API handles unicode content correctly",
    "steps": [
      "Step 1: POST /ingest with content containing Chinese, Arabic, emoji characters",
      "Step 2: Verify document created successfully",
      "Step 3: Query and verify content preserved correctly"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "YouTube URL parser handles various URL formats",
    "steps": [
      "Step 1: Test youtube.com/watch?v=XXX format",
      "Step 2: Test youtu.be/XXX format",
      "Step 3: Test youtube.com/embed/XXX format",
      "Step 4: Verify all extract correct video_id"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "YouTube playlist URL detection and parsing",
    "steps": [
      "Step 1: Test youtube.com/playlist?list=XXX format",
      "Step 2: Test youtube.com/watch?v=XXX&list=XXX format",
      "Step 3: Verify playlist_id extracted correctly"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Docker compose starts all services correctly",
    "steps": [
      "Step 1: Run docker-compose up",
      "Step 2: Verify Qdrant container is healthy",
      "Step 3: Verify Ollama container is healthy",
      "Step 4: Verify FastAPI service container is healthy",
      "Step 5: Verify rag-net network created"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Docker network connectivity between services",
    "steps": [
      "Step 1: Start all containers",
      "Step 2: Verify FastAPI can reach Qdrant on rag-net",
      "Step 3: Verify FastAPI can reach Ollama on rag-net",
      "Step 4: Verify FastAPI can reach external Supabase"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Ollama model availability check at startup",
    "steps": [
      "Step 1: Start service without nomic-embed-text model pulled",
      "Step 2: Verify service logs clear error about missing model",
      "Step 3: Pull model: ollama pull nomic-embed-text",
      "Step 4: Restart service and verify startup succeeds"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "n8n workflow lock pattern prevents concurrent processing",
    "steps": [
      "Step 1: Set row status to 'queued'",
      "Step 2: Trigger workflow",
      "Step 3: Verify status changes to 'processing'",
      "Step 4: Verify lease_expires_at is set",
      "Step 5: Attempt second trigger on same row",
      "Step 6: Verify second trigger is blocked"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "n8n workflow lease expiration allows reprocessing",
    "steps": [
      "Step 1: Set row to status='processing' with expired lease_expires_at",
      "Step 2: Trigger workflow",
      "Step 3: Verify row is picked up for reprocessing",
      "Step 4: Verify attempt_count incremented"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "n8n workflow state transitions for success",
    "steps": [
      "Step 1: Insert row with status='queued'",
      "Step 2: Wait for workflow to process",
      "Step 3: Verify status changes to 'processing'",
      "Step 4: Verify final status is 'ingested'",
      "Step 5: Verify doc_id is populated"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "n8n workflow state transitions for error",
    "steps": [
      "Step 1: Insert row with invalid URL",
      "Step 2: Wait for workflow to process",
      "Step 3: Verify final status is 'error'",
      "Step 4: Verify error_reason is populated"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "n8n workflow playlist fan-out creates child rows",
    "steps": [
      "Step 1: Insert row with playlist URL",
      "Step 2: Wait for workflow to process",
      "Step 3: Verify parent status is 'queued_children'",
      "Step 4: Verify child rows created with status='queued'",
      "Step 5: Verify child rows have playlist_id set"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "n8n workflow fan-out is idempotent",
    "steps": [
      "Step 1: Insert playlist row and let it expand",
      "Step 2: Note child rows created",
      "Step 3: Manually trigger workflow again on parent",
      "Step 4: Verify no duplicate child rows created"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "n8n workflow retry logic for retryable errors",
    "steps": [
      "Step 1: Configure mock to return retryable error",
      "Step 2: Insert row",
      "Step 3: Verify status becomes 'retry' after first failure",
      "Step 4: Verify attempt_count is incremented",
      "Step 5: After lease expires, verify row is reprocessed"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Google Sheet schema has all required columns",
    "steps": [
      "Step 1: Open YouTube Ingest Queue sheet",
      "Step 2: Verify 'url' column exists",
      "Step 3: Verify 'status' column exists",
      "Step 4: Verify 'run_id' column exists",
      "Step 5: Verify 'attempt_count' column exists",
      "Step 6: Verify 'started_at' column exists",
      "Step 7: Verify 'finished_at' column exists",
      "Step 8: Verify 'lease_expires_at' column exists",
      "Step 9: Verify 'video_id' column exists",
      "Step 10: Verify 'playlist_id' column exists",
      "Step 11: Verify 'doc_id' column exists",
      "Step 12: Verify 'error_reason' column exists"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "API returns proper HTTP status codes for all scenarios",
    "steps": [
      "Step 1: Successful creation returns 201",
      "Step 2: Successful query returns 200",
      "Step 3: Validation error returns 422",
      "Step 4: Not found returns 404",
      "Step 5: Server error returns 500"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Async database operations use connection pooling",
    "steps": [
      "Step 1: Start service and check initial pool connections",
      "Step 2: Send 50 concurrent requests",
      "Step 3: Verify connection pool is reused (not 50 new connections)",
      "Step 4: Verify no connection exhaustion"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Service graceful shutdown preserves in-flight requests",
    "steps": [
      "Step 1: Start long-running /ingest request",
      "Step 2: Send shutdown signal to service",
      "Step 3: Verify in-flight request completes",
      "Step 4: Verify new requests are rejected",
      "Step 5: Verify service shuts down cleanly"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Timing spans logged for pipeline stages",
    "steps": [
      "Step 1: POST /ingest",
      "Step 2: Check logs for timing information",
      "Step 3: Verify chunking duration logged",
      "Step 4: Verify embedding duration logged",
      "Step 5: Verify database write duration logged"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Error tracking includes actionable information",
    "steps": [
      "Step 1: Cause various errors",
      "Step 2: Verify error responses include error code",
      "Step 3: Verify error responses include message",
      "Step 4: Verify error responses include detail when appropriate"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Workspace isolation - queries only return workspace data",
    "steps": [
      "Step 1: Ingest document in workspace A",
      "Step 2: Ingest document in workspace B",
      "Step 3: POST /query for workspace A",
      "Step 4: Verify results only from workspace A",
      "Step 5: POST /query for workspace B",
      "Step 6: Verify results only from workspace B"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Multiple embedding providers can coexist",
    "steps": [
      "Step 1: Ingest using ollama provider",
      "Step 2: Run /reembed with different provider",
      "Step 3: Verify chunk_vectors has records for both providers",
      "Step 4: Verify query can target specific collection"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Document version tracking increments correctly",
    "steps": [
      "Step 1: Ingest document (version 1)",
      "Step 2: Update document",
      "Step 3: Verify new document has version 2",
      "Step 4: Update again",
      "Step 5: Verify version is 3"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "last_indexed_at updates when vectors created",
    "steps": [
      "Step 1: Ingest document",
      "Step 2: Check last_indexed_at is set",
      "Step 3: Run /reembed",
      "Step 4: Verify last_indexed_at updated to recent time"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Content hash is deterministic",
    "steps": [
      "Step 1: Hash specific content string",
      "Step 2: Hash same content string again",
      "Step 3: Verify hashes match",
      "Step 4: Hash different content",
      "Step 5: Verify hash is different"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Point ID in Qdrant matches chunk_id exactly",
    "steps": [
      "Step 1: Ingest document",
      "Step 2: Get chunk_ids from database",
      "Step 3: Query Qdrant for points",
      "Step 4: Verify point IDs match chunk UUIDs 1:1"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Qdrant delete removes vectors on document supersede",
    "steps": [
      "Step 1: Ingest document version 1",
      "Step 2: Note chunk_ids",
      "Step 3: Update to version 2",
      "Step 4: Query Qdrant for old chunk_ids",
      "Step 5: Verify old vectors are deleted"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Query with no results returns empty array",
    "steps": [
      "Step 1: POST /query for non-existent content",
      "Step 2: Verify results is empty array []",
      "Step 3: Verify no error raised"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Combined filters work together correctly",
    "steps": [
      "Step 1: Ingest diverse documents",
      "Step 2: POST /query with source_types AND symbols AND date_range filters",
      "Step 3: Verify results match ALL filter criteria"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Language field stored for multi-language content",
    "steps": [
      "Step 1: Ingest English document",
      "Step 2: Verify language field is 'en'",
      "Step 3: Ingest document with explicit language='es'",
      "Step 4: Verify language stored correctly"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Service recovers from temporary Qdrant outage",
    "steps": [
      "Step 1: Service running normally",
      "Step 2: Stop Qdrant",
      "Step 3: Verify service logs connection error",
      "Step 4: Restart Qdrant",
      "Step 5: Verify service reconnects and resumes working"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Service recovers from temporary Supabase outage",
    "steps": [
      "Step 1: Service running normally",
      "Step 2: Simulate Supabase connection failure",
      "Step 3: Verify appropriate error response",
      "Step 4: Restore connection",
      "Step 5: Verify service resumes working"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Section field tracks document structure",
    "steps": [
      "Step 1: Ingest document with section headers",
      "Step 2: Query chunks",
      "Step 3: Verify section field populated where applicable"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Token counting is accurate",
    "steps": [
      "Step 1: Ingest known content with counted tokens",
      "Step 2: Query chunk token_count",
      "Step 3: Verify token_count matches expected (within 5% tolerance)"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Composite FK constraint (doc_id, workspace_id) enforced",
    "steps": [
      "Step 1: Attempt to insert chunk with mismatched workspace_id",
      "Step 2: Verify foreign key constraint violation",
      "Step 3: Insert chunk with matching doc_id and workspace_id",
      "Step 4: Verify success"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "GIN indexes on arrays improve filter performance",
    "steps": [
      "Step 1: Ingest 1000+ documents with various symbols",
      "Step 2: Explain query filtering by symbols",
      "Step 3: Verify GIN index is used",
      "Step 4: Verify query time is sub-100ms"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Published_at index improves date range queries",
    "steps": [
      "Step 1: Ingest 1000+ documents with various dates",
      "Step 2: Explain date range query",
      "Step 3: Verify index is used",
      "Step 4: Verify query time is sub-100ms"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Over-fetch pattern retrieves more than top_k",
    "steps": [
      "Step 1: POST /query with retrieve_k=20, top_k=5",
      "Step 2: Verify Qdrant search fetches 20 results",
      "Step 3: Verify final response has 5 results",
      "Step 4: Verify reranking selected best 5 from 20"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Answer model is configurable per request",
    "steps": [
      "Step 1: POST /query with answer_model='anthropic/claude-3-haiku'",
      "Step 2: Verify that model is used for generation",
      "Step 3: POST /query with different answer_model",
      "Step 4: Verify different model used"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Job failure captured with error details",
    "steps": [
      "Step 1: POST /reembed with invalid configuration",
      "Step 2: GET /jobs/{job_id}",
      "Step 3: Verify status is 'failed'",
      "Step 4: Verify error field contains useful information"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "API versioning or compatibility handling",
    "steps": [
      "Step 1: Check if API version header exists",
      "Step 2: Verify backwards compatibility for schema changes"
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "API responses follow consistent JSON structure",
    "steps": [
      "Step 1: Check all success responses",
      "Step 2: Verify consistent field naming (snake_case)",
      "Step 3: Verify consistent data types",
      "Step 4: Verify null handling is consistent"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Error responses follow consistent format",
    "steps": [
      "Step 1: Trigger various error types",
      "Step 2: Verify all errors have 'detail' field",
      "Step 3: Verify consistent error structure"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "OpenAPI/Swagger documentation is complete",
    "steps": [
      "Step 1: Access /docs or /openapi.json",
      "Step 2: Verify all endpoints documented",
      "Step 3: Verify request/response schemas documented",
      "Step 4: Verify example values provided"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "FastAPI auto-generated docs are accessible",
    "steps": [
      "Step 1: Navigate to /docs",
      "Step 2: Verify Swagger UI loads",
      "Step 3: Navigate to /redoc",
      "Step 4: Verify ReDoc loads"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Log format is JSON structured and consistent",
    "steps": [
      "Step 1: Collect sample of 20 log entries",
      "Step 2: Verify all are valid JSON",
      "Step 3: Verify consistent field names",
      "Step 4: Verify timestamp format is ISO8601"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Log levels are appropriate for message types",
    "steps": [
      "Step 1: Verify INFO for normal operations",
      "Step 2: Verify WARN for recoverable issues",
      "Step 3: Verify ERROR for failures",
      "Step 4: Verify DEBUG for detailed tracing"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Configuration uses environment variables consistently",
    "steps": [
      "Step 1: List all configuration options",
      "Step 2: Verify all are set via environment variables",
      "Step 3: Verify naming follows convention (UPPERCASE_WITH_UNDERSCORES)"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Python code follows PEP 8 style guidelines",
    "steps": [
      "Step 1: Run linter (flake8/pylint) on codebase",
      "Step 2: Verify no critical style violations",
      "Step 3: Verify consistent formatting"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Type hints are used throughout the codebase",
    "steps": [
      "Step 1: Run mypy on codebase",
      "Step 2: Verify function signatures have type hints",
      "Step 3: Verify Pydantic models use proper types"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Async/await used consistently (no blocking calls)",
    "steps": [
      "Step 1: Review code for sync HTTP calls",
      "Step 2: Verify httpx async client used",
      "Step 3: Verify asyncpg used for database",
      "Step 4: Verify no time.sleep() calls in async code"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Docker compose file is well-organized",
    "steps": [
      "Step 1: Verify service definitions are clear",
      "Step 2: Verify environment variables documented",
      "Step 3: Verify volumes and networks named appropriately",
      "Step 4: Verify healthchecks defined"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Dockerfile follows best practices",
    "steps": [
      "Step 1: Verify multi-stage build if applicable",
      "Step 2: Verify minimal base image",
      "Step 3: Verify non-root user",
      "Step 4: Verify proper layer caching (requirements before code)"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "README documentation is comprehensive",
    "steps": [
      "Step 1: Verify project description exists",
      "Step 2: Verify setup instructions exist",
      "Step 3: Verify API endpoint documentation exists",
      "Step 4: Verify environment variable documentation exists"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Code comments explain complex logic",
    "steps": [
      "Step 1: Review complex functions",
      "Step 2: Verify non-obvious logic has comments",
      "Step 3: Verify comments are up-to-date with code"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Docstrings provided for public functions",
    "steps": [
      "Step 1: List public functions/methods",
      "Step 2: Verify docstrings exist",
      "Step 3: Verify docstrings describe parameters and returns"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Module organization follows clean architecture",
    "steps": [
      "Step 1: Verify clear separation of concerns",
      "Step 2: Verify repositories separate from business logic",
      "Step 3: Verify schemas separate from models"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Error messages are user-friendly",
    "steps": [
      "Step 1: Review error message strings",
      "Step 2: Verify messages are clear and actionable",
      "Step 3: Verify no internal details leaked"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Consistent naming conventions across codebase",
    "steps": [
      "Step 1: Verify snake_case for Python variables/functions",
      "Step 2: Verify PascalCase for classes",
      "Step 3: Verify UPPER_SNAKE_CASE for constants",
      "Step 4: Verify consistency in schema field names"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Git commit messages follow conventional format",
    "steps": [
      "Step 1: Review recent commits",
      "Step 2: Verify descriptive commit messages",
      "Step 3: Verify messages start with verb (Add, Fix, Update)"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": ".gitignore includes appropriate entries",
    "steps": [
      "Step 1: Verify .env is ignored",
      "Step 2: Verify __pycache__ is ignored",
      "Step 3: Verify .venv is ignored",
      "Step 4: Verify IDE files are ignored"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Secrets not committed to repository",
    "steps": [
      "Step 1: Search for API keys in code",
      "Step 2: Search for passwords in code",
      "Step 3: Verify .env.example has placeholders not real values"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "API endpoints use RESTful conventions",
    "steps": [
      "Step 1: Verify nouns for resources (/documents, /jobs)",
      "Step 2: Verify appropriate HTTP methods (GET, POST)",
      "Step 3: Verify plural nouns for collections"
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "Response times displayed in health endpoint",
    "steps": [
      "Step 1: GET /health",
      "Step 2: Verify latency_ms object is formatted clearly",
      "Step 3: Verify units are consistent (all ms)"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Pydantic models have proper field descriptions",
    "steps": [
      "Step 1: Review Pydantic models in schemas.py",
      "Step 2: Verify Field() has description parameter",
      "Step 3: Verify descriptions appear in OpenAPI docs"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Configuration has sensible defaults",
    "steps": [
      "Step 1: Review config.py defaults",
      "Step 2: Verify timeouts have reasonable defaults",
      "Step 3: Verify batch sizes have reasonable defaults"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Dependencies pinned in requirements.txt",
    "steps": [
      "Step 1: Check requirements.txt exists",
      "Step 2: Verify versions are pinned (==)",
      "Step 3: Verify no vulnerable versions"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingest pipeline handles very long documents (50000+ tokens)",
    "steps": [
      "Step 1: Prepare document with 50000+ tokens",
      "Step 2: POST /ingest",
      "Step 3: Verify successful completion",
      "Step 4: Verify appropriate number of chunks created",
      "Step 5: Verify no memory issues or timeouts"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Query handles special characters in question",
    "steps": [
      "Step 1: POST /query with question containing quotes, brackets, etc.",
      "Step 2: Verify query executes without error",
      "Step 3: Verify results returned appropriately"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "YouTube ingestion handles live streams appropriately",
    "steps": [
      "Step 1: POST /sources/youtube/ingest with live stream URL",
      "Step 2: Verify appropriate error or handling",
      "Step 3: Verify retryable flag is correct"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "YouTube ingestion handles age-restricted videos",
    "steps": [
      "Step 1: POST /sources/youtube/ingest with age-restricted video URL",
      "Step 2: Verify appropriate error handling",
      "Step 3: Verify error_reason explains the issue"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Qdrant collection auto-creation if not exists",
    "steps": [
      "Step 1: Delete target collection from Qdrant",
      "Step 2: Start service",
      "Step 3: Verify service creates collection automatically",
      "Step 4: Verify collection has correct settings"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Database migrations can be run safely",
    "steps": [
      "Step 1: Check for migration scripts",
      "Step 2: Run migrations on fresh database",
      "Step 3: Verify tables created correctly",
      "Step 4: Run migrations again",
      "Step 5: Verify idempotent (no errors on re-run)"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Service starts within reasonable time (<30 seconds)",
    "steps": [
      "Step 1: Time service startup",
      "Step 2: Verify startup completes in <30 seconds",
      "Step 3: Verify /health returns OK immediately after startup"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Memory usage stays bounded under load",
    "steps": [
      "Step 1: Record initial memory usage",
      "Step 2: Run 100 ingest operations",
      "Step 3: Check memory usage after load",
      "Step 4: Verify no memory leak (usage returns to baseline)"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Ingest throughput meets target (>10 docs/minute)",
    "steps": [
      "Step 1: Prepare 20 sample documents",
      "Step 2: Time ingestion of all 20",
      "Step 3: Verify throughput > 10 docs/minute"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Query latency meets target (<2 seconds p95)",
    "steps": [
      "Step 1: Run 100 queries",
      "Step 2: Record latencies",
      "Step 3: Calculate p95 latency",
      "Step 4: Verify p95 < 2000ms"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Health endpoint latency target (<100ms)",
    "steps": [
      "Step 1: Run 50 /health requests",
      "Step 2: Record latencies",
      "Step 3: Verify average < 100ms"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Service handles URL encoding in YouTube URLs",
    "steps": [
      "Step 1: POST /sources/youtube/ingest with URL containing encoded characters",
      "Step 2: Verify URL is decoded correctly",
      "Step 3: Verify video_id extracted correctly"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Metadata extraction handles content with no detectable entities",
    "steps": [
      "Step 1: Ingest content with no symbols, entities, or topics",
      "Step 2: Verify chunks created with empty arrays",
      "Step 3: Verify no errors raised"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Query with workspace_id that has no documents returns empty results",
    "steps": [
      "Step 1: POST /query with workspace_id that has no data",
      "Step 2: Verify results array is empty",
      "Step 3: Verify no error raised",
      "Step 4: Verify response time is still fast"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Reembed job handles empty workspace gracefully",
    "steps": [
      "Step 1: POST /reembed for workspace with no documents",
      "Step 2: Verify job completes successfully",
      "Step 3: Verify chunks_queued is 0"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Multiple workspaces can be processed concurrently",
    "steps": [
      "Step 1: Send concurrent /ingest requests for different workspaces",
      "Step 2: Verify all complete successfully",
      "Step 3: Verify data isolated per workspace"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Service logs request duration for all endpoints",
    "steps": [
      "Step 1: Send requests to various endpoints",
      "Step 2: Check logs for duration information",
      "Step 3: Verify duration logged in milliseconds"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "CORS headers configured for cross-origin requests",
    "steps": [
      "Step 1: Send OPTIONS request",
      "Step 2: Verify Access-Control-Allow-Origin header",
      "Step 3: Verify Access-Control-Allow-Methods header"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Rate limiting prevents abuse",
    "steps": [
      "Step 1: Send 100 rapid requests",
      "Step 2: Verify rate limit kicks in",
      "Step 3: Verify 429 status returned when limited"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Service validates API keys/tokens if configured",
    "steps": [
      "Step 1: Configure API key requirement",
      "Step 2: Send request without key",
      "Step 3: Verify 401 or 403 response",
      "Step 4: Send request with valid key",
      "Step 5: Verify success"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Ingest request size limits enforced",
    "steps": [
      "Step 1: Send very large request (>10MB)",
      "Step 2: Verify appropriate error response",
      "Step 3: Verify service doesn't crash"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "SQL injection prevented in queries",
    "steps": [
      "Step 1: Send query with SQL injection attempt in filters",
      "Step 2: Verify no SQL execution",
      "Step 3: Verify parameterized queries used"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "XSS prevention in stored content",
    "steps": [
      "Step 1: Ingest content with script tags",
      "Step 2: Query content back",
      "Step 3: Verify content is properly escaped or raw (not executed)"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Chunk content_hash is unique per chunk content",
    "steps": [
      "Step 1: Create chunks with different content",
      "Step 2: Verify each has unique content_hash",
      "Step 3: Create chunks with identical content",
      "Step 4: Verify they have same content_hash"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Document deletion cascades to chunks and vectors",
    "steps": [
      "Step 1: Ingest document",
      "Step 2: Note chunk_ids and vector point_ids",
      "Step 3: Delete document",
      "Step 4: Verify chunks deleted from database",
      "Step 5: Verify vectors deleted from Qdrant"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Partial failure during ingest is handled atomically",
    "steps": [
      "Step 1: Configure failure after chunk creation but before vector creation",
      "Step 2: POST /ingest",
      "Step 3: Verify transaction rolled back",
      "Step 4: Verify no orphan chunks in database"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Qdrant upsert is idempotent",
    "steps": [
      "Step 1: Upsert vector with specific point_id",
      "Step 2: Upsert same vector again",
      "Step 3: Verify no duplicate points",
      "Step 4: Verify data is unchanged"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Published_at null handling in filters",
    "steps": [
      "Step 1: Ingest document without published_at",
      "Step 2: Query with date range filter",
      "Step 3: Verify null published_at documents excluded from date-filtered results"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Empty filters return all results (no filter applied)",
    "steps": [
      "Step 1: POST /query with empty filters object",
      "Step 2: Verify all workspace documents considered",
      "Step 3: Verify results based purely on semantic relevance"
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "Service port configurable via environment",
    "steps": [
      "Step 1: Set PORT=8080 in environment",
      "Step 2: Start service",
      "Step 3: Verify service listens on port 8080"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Service host configurable (0.0.0.0 for Docker)",
    "steps": [
      "Step 1: Verify host configured as 0.0.0.0",
      "Step 2: Verify service accessible from outside container"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Healthcheck in Dockerfile works",
    "steps": [
      "Step 1: Build Docker image",
      "Step 2: Run container",
      "Step 3: Check docker ps shows healthy status"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Docker image size is reasonable (<1GB)",
    "steps": [
      "Step 1: Build Docker image",
      "Step 2: Check image size",
      "Step 3: Verify size < 1GB"
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "Environment variables have .env.example template",
    "steps": [
      "Step 1: Check .env.example exists",
      "Step 2: Verify all required variables listed",
      "Step 3: Verify placeholder values (not real secrets)"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Development dependencies separate from production",
    "steps": [
      "Step 1: Check requirements-dev.txt or pyproject.toml dev deps",
      "Step 2: Verify test/lint deps not in production requirements"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Embedding batch size is configurable",
    "steps": [
      "Step 1: Set EMBED_BATCH_SIZE=50 in environment",
      "Step 2: Ingest large document",
      "Step 3: Verify embeddings processed in batches of 50"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Query timeout prevents runaway queries",
    "steps": [
      "Step 1: Configure short query timeout",
      "Step 2: Send query that would take too long",
      "Step 3: Verify timeout error returned",
      "Step 4: Verify service remains responsive"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Qdrant search timeout prevents hanging",
    "steps": [
      "Step 1: Configure Qdrant timeout",
      "Step 2: Simulate slow Qdrant response",
      "Step 3: Verify service doesn't hang indefinitely"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "OpenRouter API timeout configured",
    "steps": [
      "Step 1: Configure OpenRouter timeout",
      "Step 2: Simulate slow API response",
      "Step 3: Verify timeout error returned",
      "Step 4: Verify retryable flag is true"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Chunk overlap configurable for context preservation",
    "steps": [
      "Step 1: Configure chunk overlap tokens",
      "Step 2: Ingest document",
      "Step 3: Verify chunk boundaries have appropriate overlap"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Different tokenizers supported for different models",
    "steps": [
      "Step 1: Configure tokenizer for nomic-embed-text",
      "Step 2: Verify token counts accurate",
      "Step 3: Configure different tokenizer",
      "Step 4: Verify token counts change appropriately"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Transcript fetch supports multiple languages",
    "steps": [
      "Step 1: Ingest video with Spanish transcript",
      "Step 2: Verify transcript fetched successfully",
      "Step 3: Verify language field set correctly"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Transcript fallback to auto-generated if manual unavailable",
    "steps": [
      "Step 1: Ingest video with only auto-generated transcript",
      "Step 2: Verify transcript fetched successfully",
      "Step 3: Verify quality_score reflects auto-generated nature"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Citation URLs use canonical_url when source_url unavailable",
    "steps": [
      "Step 1: Ingest document with canonical_url but no source_url",
      "Step 2: Query and get citations",
      "Step 3: Verify citation uses canonical_url"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Locator label for PDF uses page numbers",
    "steps": [
      "Step 1: Ingest PDF with page information",
      "Step 2: Query chunks",
      "Step 3: Verify locator_label format is 'p. X' or 'pp. X-Y'"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Multi-page PDF chunk spans tracked correctly",
    "steps": [
      "Step 1: Ingest PDF where chunk spans pages 5-7",
      "Step 2: Query chunk",
      "Step 3: Verify page_start=5 and page_end=7"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Article source type ingestion works",
    "steps": [
      "Step 1: POST /ingest with source_type='article'",
      "Step 2: Verify document created",
      "Step 3: Verify chunks created",
      "Step 4: Verify vectors created"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Note source type ingestion works",
    "steps": [
      "Step 1: POST /ingest with source_type='note'",
      "Step 2: Verify document created with note type"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Transcript source type ingestion works",
    "steps": [
      "Step 1: POST /ingest with source_type='transcript'",
      "Step 2: Verify timestamp handling appropriate for transcript"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Service exposes Prometheus metrics endpoint",
    "steps": [
      "Step 1: GET /metrics",
      "Step 2: Verify Prometheus format metrics returned",
      "Step 3: Verify request count metrics",
      "Step 4: Verify latency histogram metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Metrics include per-endpoint breakdown",
    "steps": [
      "Step 1: Send requests to various endpoints",
      "Step 2: GET /metrics",
      "Step 3: Verify metrics labeled by endpoint"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Project has consistent directory structure",
    "steps": [
      "Step 1: Verify app/ directory for main code",
      "Step 2: Verify tests/ directory for tests",
      "Step 3: Verify clear separation of modules"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Import statements organized properly",
    "steps": [
      "Step 1: Check Python files for import organization",
      "Step 2: Verify stdlib imports first",
      "Step 3: Verify third-party imports second",
      "Step 4: Verify local imports last"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "No hardcoded values in business logic",
    "steps": [
      "Step 1: Search for magic numbers in code",
      "Step 2: Verify configurable values use config",
      "Step 3: Verify constants defined appropriately"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Database queries use parameterized statements",
    "steps": [
      "Step 1: Review database query code",
      "Step 2: Verify no string concatenation for queries",
      "Step 3: Verify all parameters are bound safely"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Exception handling is specific (not bare except)",
    "steps": [
      "Step 1: Search for exception handlers",
      "Step 2: Verify specific exception types caught",
      "Step 3: Verify no bare 'except:' clauses"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Context managers used for resource management",
    "steps": [
      "Step 1: Review code for file/connection handling",
      "Step 2: Verify 'with' statements used",
      "Step 3: Verify async context managers for async resources"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Function/method length is reasonable (<50 lines)",
    "steps": [
      "Step 1: Analyze function lengths",
      "Step 2: Verify most functions < 50 lines",
      "Step 3: Verify long functions have clear structure"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Class responsibilities are single-purpose",
    "steps": [
      "Step 1: Review class definitions",
      "Step 2: Verify each class has clear single responsibility",
      "Step 3: Verify no god classes"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "Test file naming follows convention",
    "steps": [
      "Step 1: Check tests directory",
      "Step 2: Verify test files named test_*.py",
      "Step 3: Verify test functions named test_*"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Integration tests cover main flows",
    "steps": [
      "Step 1: Check for integration test files",
      "Step 2: Verify ingest flow tested",
      "Step 3: Verify query flow tested",
      "Step 4: Verify YouTube flow tested"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Unit tests cover core functions",
    "steps": [
      "Step 1: Check for unit test files",
      "Step 2: Verify chunker tested",
      "Step 3: Verify metadata extractor tested",
      "Step 4: Verify URL parser tested"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Tests can run without external dependencies (mocked)",
    "steps": [
      "Step 1: Run unit tests without Qdrant/Supabase",
      "Step 2: Verify tests pass with mocks",
      "Step 3: Verify external calls are mocked"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Test coverage above 70%",
    "steps": [
      "Step 1: Run tests with coverage",
      "Step 2: Generate coverage report",
      "Step 3: Verify coverage > 70%"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "CI/CD pipeline configuration exists",
    "steps": [
      "Step 1: Check for .github/workflows or similar",
      "Step 2: Verify tests run on PR",
      "Step 3: Verify linting runs on PR"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "CHANGELOG maintained for releases",
    "steps": [
      "Step 1: Check for CHANGELOG.md",
      "Step 2: Verify recent changes documented"
    ],
    "passes": true
  },
  {
    "category": "style",
    "description": "VERSION file or __version__ in package",
    "steps": [
      "Step 1: Check for version indicator",
      "Step 2: Verify version in health endpoint matches"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Service handles malformed JSON gracefully",
    "steps": [
      "Step 1: Send malformed JSON to endpoint",
      "Step 2: Verify 400 or 422 error response",
      "Step 3: Verify error message is helpful"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Service handles missing Content-Type header",
    "steps": [
      "Step 1: Send POST without Content-Type header",
      "Step 2: Verify appropriate error or handling"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Large playlist handling (100+ videos)",
    "steps": [
      "Step 1: POST /sources/youtube/ingest with large playlist",
      "Step 2: Verify video_urls returned for all videos",
      "Step 3: Verify no timeout or memory issues"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Private/unlisted YouTube videos handled appropriately",
    "steps": [
      "Step 1: POST /sources/youtube/ingest with private video URL",
      "Step 2: Verify appropriate error response",
      "Step 3: Verify error_reason explains access issue"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Deleted YouTube videos handled appropriately",
    "steps": [
      "Step 1: POST /sources/youtube/ingest with deleted video URL",
      "Step 2: Verify appropriate error response",
      "Step 3: Verify retryable is false"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Connection pool size configurable",
    "steps": [
      "Step 1: Set DB_POOL_SIZE=20 in environment",
      "Step 2: Start service",
      "Step 3: Verify pool respects configuration"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Qdrant client connection pooling works",
    "steps": [
      "Step 1: Send 50 concurrent queries",
      "Step 2: Verify Qdrant connections are reused",
      "Step 3: Verify no connection exhaustion"
    ],
    "passes": false
  }
]
